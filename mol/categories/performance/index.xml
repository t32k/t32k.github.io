<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Performance on MOL</title>
    <link>http://localhost:1313/mol/categories/performance/</link>
    <description>Recent content in Performance on MOL</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
    
    <lastBuildDate>Thu, 09 Jan 2014 00:00:00 UTC</lastBuildDate>
    <atom:link href="http://localhost:1313/mol/categories/performance/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>手軽にCIを体験してみたい・その2</title>
      <link>http://localhost:1313/mol/log/casual-continuous-integration-2/</link>
      <pubDate>Thu, 09 Jan 2014 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/mol/log/casual-continuous-integration-2/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;/mol/log/casual-continuous-integration/&#34;&gt;前回の記事&lt;/a&gt;が全然手軽じゃない気がしてきたので、今回も幾分かマシにCIを体験するというかCIサーバ立てずにがんばってみる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/mol/images/2014/01-08-fig01.png&#34; alt=&#34;Jenkins・WPT・GitHub&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;前回はTravisとYSlowを使ってパフォーマンステストをしたけど、今回はJenkinsとWebPagetestを使って全く同じことをしてみる。&lt;/p&gt;

&lt;p&gt;やっぱしTravisの設定が慣れないんだなぁ。ちなみに普通のユニットテストとかだったら、アクセストークンとか必要ないのでもっと簡単にできる。僕はGruntプラグインの開発で使用している。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/t32k/grunt-csso/blob/master/.travis.yml&#34;&gt;grunt-csso/.travis.yml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/t32k/grunt-csso/blob/master/package.json&#34;&gt;grunt-csso/package.json&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例えば、grunt-cssoの設定は上記みたいな感じ。ymlは実行環境指定してあるだけだし、package.jsonは&lt;code&gt;grunt test&lt;/code&gt;のコマンドを実行してるだけで、要はnodeunitテストだ。ローカルでやるのとたいして変わらない。&lt;/p&gt;

&lt;p&gt;なので、おもしろくない。&lt;/p&gt;

&lt;h2 id=&#34;jenkins:18c6e3dfbe03018973caec507f6cf780&#34;&gt;Jenkins&lt;/h2&gt;

&lt;p&gt;やっぱり私、Jenkins触りたいんですですおおおお＾q＾！ってことで、世の中にはクラウドサービスとしてJenkinsを使えるそうで、CloudBeesってとこのDEV@cloud使ってみる。便利な世の中だ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cloudbees.com/&#34;&gt;CloudBees: The Java PaaS Company&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Freeでは月300分までのビルドまでしかできなかったり制限あるけど、ちょっとJenkinsに触りたいんです欲求ぐらいなら満たせる。&lt;/p&gt;

&lt;h3 id=&#34;jenkinsシステム設定:18c6e3dfbe03018973caec507f6cf780&#34;&gt;Jenkinsシステム設定&lt;/h3&gt;

&lt;p&gt;まず、GitHubとJenkinsの連携だけどDEV@cloudのJenkinsは&lt;a href=&#34;https://wiki.jenkins-ci.org/display/JENKINS/Git+Plugin&#34;&gt;Git Plugin&lt;/a&gt;がデフォルトでインストールしてあるのでこちらでインストールしなくてもいいので楽です。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CloudBees DEV@cloud Authorization&lt;/strong&gt;でCloudBees Public KeyをGitHubのAccount Settingsの&lt;a href=&#34;https://github.com/settings/ssh&#34;&gt;SSH Keys&lt;/a&gt;に登録しておく。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/mol/images/2014/01-08-fig02.png&#34; alt=&#34;NodeJS&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;次に後述するWebPagetest(WPT)をNode.jsから利用するのでJenkinsにNode.jsをインストールしたい。NodeJS Pluginを検索してインストールすれば、Jenkinsのシステム設定からNode.jsをバージョン管理できるようになる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.jenkins-ci.org/display/JENKINS/NodeJS+Plugin&#34;&gt;NodeJS Plugin - Jenkins - Jenkins Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また&lt;code&gt;webpagetest&lt;/code&gt;パッケージが必要なので、&lt;strong&gt;Global npm packages to install&lt;/strong&gt;からインストールできるようにしておく。&lt;/p&gt;

&lt;h3 id=&#34;jenkinsビルド設定:18c6e3dfbe03018973caec507f6cf780&#34;&gt;Jenkinsビルド設定&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;新規ジョブ作成&lt;/strong&gt;から『フリースタイル・プロジェクトのビルド』を選択する。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ソースコード管理システム&lt;/strong&gt;はGitを選択しレポジトリURLを設定する。ここでは&lt;code&gt;git@github.com:t32k/maple.git&lt;/code&gt;を指定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/mol/images/2014/01-08-fig03.png&#34; alt=&#34;SCMをポーリング&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;次は&lt;strong&gt;ビルド・トリガ&lt;/strong&gt;で、『SCMをポーリング』にチェックを入れ、スケジュールには本来Cronの設定を書くが今回はGitHubのServer Hookをトリガとするので、何も入力しない（便宜上、チェックをいれるらしい）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/mol/images/2014/01-08-fig04.png&#34; alt=&#34;Service Hooks&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;GitHubのMapleのSettingsから&lt;strong&gt;Service Hooks&lt;/strong&gt;で、Jenkins (Git plugin)を選択肢、Jenkins Urlを入力し、Activeにする。これでGitフックの設定は終わり。MapeレポジトリにコミットするとJenkinsがビルドする。&lt;/p&gt;

&lt;p&gt;ほかにもいろいろ方法があるらしいので下記ページを参照してほしい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/mechamogera/items/dbeb3a540f636bfed7af&#34;&gt;GithubからJenkinsへのServer Hook - Qiita [キータ]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次は&lt;strong&gt;ビルド環境&lt;/strong&gt;で、Provide Node &amp;amp; npm bin/ folder to PATHにチェックをする。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ビルド&lt;/strong&gt;には『シェルの実行』を選択し、下記のようなコマンドを設定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout gh-pages
git rebase origin/master
git push origin gh-pages
git checkout master
test/test.sh YOUR_PRIVATE_INSTANCE_URL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要はmasterの内容をgh-pagesのブランチにマージしてWebPagetestを走らせているのだ。このへんはシェルでどうにでもできるので使い勝手がいい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/mol/images/2014/01-08-fig05.png&#34; alt=&#34;JUnitテスト結果の集計&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;で最後に、&lt;strong&gt;ビルド後の処理&lt;/strong&gt;としてJUnitテスト結果の集計を選択して、WebPagetestのテスト結果XMLのファイル名を選択すれば、Jenkinsのひと通りの設定は終わりだ。&lt;/p&gt;

&lt;h2 id=&#34;webpagetest:18c6e3dfbe03018973caec507f6cf780&#34;&gt;WebPagetest&lt;/h2&gt;

&lt;p&gt;WebPagetestはこのブログでも何回か紹介しているが、Webパフォーマンスの計測サービスだ。それをNode.jsのラッパーでCLIからテストを実行できるようにしたのが&lt;strong&gt;webpagetest-api&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/marcelduran/webpagetest-api&#34;&gt;marcelduran/webpagetest-api&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これを利用するには自分でプライベートインスタンスを作ってそこでテストを実行させるか、パブリックインスタンス上でテストを実行させるかの2つだけど、後者はWPTの作者にメールしてAPIキーをもらわなきゃいけない。&lt;/p&gt;

&lt;p&gt;もうこの辺りから全然お手軽でもないんだけども、プライベートインスタンスとか立ち上げるのだるいし（弊社にはあるのでウェーイ♪、今回の例ではAPIキーを利用していない）、とりあえず、Please API Key!ってメール投げてみましょう。1日200回までなら実行可能っぽいす。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/marcelduran/webpagetest-api/issues/8&#34;&gt;how can i get an api key? · Issue #8 · marcelduran/webpagetest-api&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;webpagetest test http://t32k.me/maple/test/fixtures/perf_test.html --server $1 --poll 3 --specs test/spec.json --reporter xunit &amp;gt; webpagetest.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/t32k/maple/blob/master/test/test.sh&#34;&gt;maple/test/test.sh · t32k/maple&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とりま、このラッパーを使って上記のようなコマンドをシェルファイルとして実行している。今回は&lt;code&gt;--server $1&lt;/code&gt;でプライベートインスタンスのURLを指定しているけど、みなさんは代わりに&lt;code&gt;--key $1&lt;/code&gt;でAPIキーを引数でとるようにしてもらえればよいかと思います。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--poll 3&lt;/code&gt;は、WPTのテストを実行しただけでは結果がかえってくるまで時間がかかるので3秒ごとにポーリングして結果が帰ってくるまで待ってるって意味。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--specs test/spec.json&lt;/code&gt;にはどの項目がどの程度のパフォーマンスまで許容できるのかしきい値を書いておく。&lt;/p&gt;

&lt;p&gt;MapleのスペックではfistViewでリクエストが50、renderタイムが5000ms、loadTimeが10000msを超えるようであれば失敗とみなしている。ここら辺りは今はちょっと適当にやってるのだけど、YSlowに比べていろんな指標をWPTではチェックできるのでこんな風にしてスペック書くんだよってことを理解してもらえればよいです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/t32k/maple/blob/master/test/spec.json&#34;&gt;maple/test/spec.json · t32k/maple&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;reporter xunit &amp;gt; webpagetest.xml&lt;/code&gt; 最後はXML形式でテスト結果を保存するよーって意味です。これをJenkinsに読み取らせて、Jenkins上でテスト結果が確認できるのです。&lt;/p&gt;

&lt;p&gt;細かな設定に関してはここをみるとよいです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/marcelduran/webpagetest-api/wiki/Test-specs#jenkins-integration&#34;&gt;Test specs · marcelduran/webpagetest-api Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ほんとは、TAP形式のレポートのほうが見やすくて良いのだけど、CloudBeesのJenkinsにはTAPレポートを表示させるJenkinsプラグインがインストール出来ないからJUnit形式にしている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/mol/images/2014/01-08-fig06.png&#34; alt=&#34;テスト結果&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;で、適当になんかPushしてやると、Jenkinsたんがビルドを走らせて上記のような結果を頂けます。&lt;/p&gt;

&lt;p&gt;んなわけでやっぱJenkinsでこれだけいろいろできるのはよいなーと思いました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>手軽にCIを体験してみたい</title>
      <link>http://localhost:1313/mol/log/casual-continuous-integration/</link>
      <pubDate>Tue, 07 Jan 2014 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/mol/log/casual-continuous-integration/</guid>
      <description>

&lt;p&gt;昨年の&lt;a href=&#34;http://frontrend.github.io/events/06/&#34;&gt;Frontrend/06&lt;/a&gt;では、全くもってながら個人的な趣向のもと継続インテグレーション（CI:Continuous Integration）をテーマに開催した。もはや、フロントエンドとは！という感じだが、非常に良いイベントだったと思う。&lt;/p&gt;

&lt;p&gt;基本的に昨今のフロントエンドは膨大なタスクに追われている、そのようなタスクを手動でちまちまやっていては手戻りやミスなど必ず発生するので自動化すべきである。フロントエンドの自動化は&lt;a href=&#34;/mol/log/modern-development-workflow-with-grunt/&#34;&gt;Grunt&lt;/a&gt;などがあるが、結局フロントだけで問題を解決しようとすると問題（限界）があったりするので、CIサーバーとか使ったほうがいいよね。てかフロントエンドの人も慣れておいたほうがいいよねって話。&lt;/p&gt;

&lt;p&gt;しかし、フロントエンドの人が&lt;a href=&#34;/mol/log/vagrant1-2-centos6-4-jenkins1-5/&#34;&gt;いちからJenkinsを立ち上げたり&lt;/a&gt;するのもさほど面倒でもないが多少の心理的障壁があるので、もっとカジュアルに利用したい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/mol/images/2014/01-07-fig01.png&#34; alt=&#34;Build・Test・Commit&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.slideshare.net/st44100/ss-28353683&#34;&gt;Frontend/06の佐竹さんのセッション&lt;/a&gt;でCIを構成する要素として、Build・Test・Commitの3つがあると紹介されていた。Commitは普段Gitを使ってるから馴染み深いというかGitHub使ってるよね？みんな！！ってことで問題無いとして、Build/TestをなんとかCIサーバーでやってもらいたい。Testに関してはJavaScriptのTestなんかフロントエンドの人もやるので問題ないかと思うけど僕はそんなJavaScriptとか書かないのでよくわからないので、今回はWeb Performanceのテストをやってみるよ。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/mol/images/2014/01-07-fig02.png&#34; alt=&#34;Travis・YSlow・GitHub&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;今回のGitHubのレポジトリ(master)にPushしたら、Travisがgh-pagesブランチに同じ内容をコミットして反映された(gh-pagesの)ページのパフォーマンスをYSlowで検証してみるという流れだ。&lt;/p&gt;

&lt;p&gt;gh-pagesをDev環境と見立てて、Dev環境でBuildした内容がパフォーマンス的に不適切（テストが失敗）ならProduction環境にはリリースできない・させないというようなサイクルを想定している。&lt;/p&gt;

&lt;p&gt;今回はMapleの下記のファイルを検証してみる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/t32k/maple/blob/master/test/fixtures/perf_test.html&#34;&gt;maple/test/fixtures/perf_test.html at master · t32k/maple&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これがgh-pagesにマージしてやると、下記のURLでホストされる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://t32k.me/maple/test/fixtures/perf_test.html&#34;&gt;http://t32k.me/maple/test/fixtures/perf_test.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;travis-ci:e7b29da31b832ac8d2309a565b9ab096&#34;&gt;Travis-CI&lt;/h2&gt;

&lt;p&gt;CIサーバーはなにもJenkinsだけではない。GitHub上でレポジトリを管理しているのなら連携している&lt;a href=&#34;https://travis-ci.org/&#34;&gt;Travis-CI&lt;/a&gt;を使用するのが何かと都合がよい。&lt;/p&gt;

&lt;p&gt;Travisを使うにはアカウントを連携して、自分の&lt;a href=&#34;https://travis-ci.org/profile&#34;&gt;プロフィール&lt;/a&gt;から検証したいレポジトリを&lt;code&gt;ON&lt;/code&gt;にする。&lt;/p&gt;

&lt;p&gt;Travisをどのように使用するかは&lt;code&gt;.travis.yml&lt;/code&gt;というファイルに記述する。Mapleでの設定は下記ファイルを見てもらえればよい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/t32k/maple/blob/master/.travis.yml&#34;&gt;maple/.travis.yml at master · t32k/maple&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;language: node_js
node_js: 0.10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最初の行は実行環境を指定する。node.jsを使ったテストがしたいので、&lt;code&gt;node_js&lt;/code&gt;を指定する。バージョンは0.8、0.10とか複数指定できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;env:
  global:
    - GIT_AUTHOR_NAME=t32k
    - GIT_AUTHOR_EMAIL=ijok.ijok@gmail.com
    - GIT_COMMITTER_NAME=t32k
    - GIT_COMMITTER_EMAIL=ijok.ijok@gmail.com
    - secure: &amp;quot;Xtk................&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TravisからGitHubにコミットするには、OAuth access tokensが必要になので&lt;a href=&#34;https://github.com/settings/applications&#34;&gt;ここから発行する&lt;/a&gt;。そんでトークンをこんなパブリックなところに公開できないので、コマンドラインの&lt;code&gt;travis&lt;/code&gt;で暗号化したのが&lt;code&gt;secure&lt;/code&gt;のところ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install travis
$ travis encrypt -r t32k/maple &amp;quot;GH_TOKEN=&amp;lt;生成したトークン&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで暗号化する。詳しくは下記のサイトを参照して欲しい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tricknotes.hateblo.jp/entry/2013/06/17/020229&#34;&gt;Middleman で作った web サイトを Travis + GitHub pages でお手軽に運用する - tricknotesのぼうけんのしょ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://1000ch.net/2013/08/30/MiddlemanAndGruntOnTravis/&#34;&gt;MiddlemanとTravis CIでgh-pagesを運用したら身長が伸びた | 1000ch.net&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まぁ、GitHubの設定をしてるとこです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;before_script:
  - &amp;quot;git clone --quiet https://github.com/t32k/maple.git&amp;quot;
  - &amp;quot;git checkout -b gh-pages&amp;quot;
  - &amp;quot;git rebase master&amp;quot;
  - &amp;quot;[ \&amp;quot;$TRAVIS_BRANCH\&amp;quot; == \&amp;quot;master\&amp;quot; ] &amp;amp;&amp;amp; [ $GH_TOKEN ] &amp;amp;&amp;amp; git push --quiet https://$GH_TOKEN@github.com/t32k/maple.git gh-pages 2&amp;gt; /dev/null&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;before_script&lt;/code&gt;はtestが実行する前に実行しておきたいコマンドで、ここでは、masterブランチの内容をgh-pagesにマージしてプッシュしてる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;script:
  - &amp;quot;npm test&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、最後にテストコマンドを実行って流れ。&lt;/p&gt;

&lt;h2 id=&#34;yslow:e7b29da31b832ac8d2309a565b9ab096&#34;&gt;YSlow&lt;/h2&gt;

&lt;p&gt;で、次はパフォーマンスのテスト内容に関して。&lt;a href=&#34;http://yslow.org/&#34;&gt;YSlow&lt;/a&gt;はFirefoxとかChromeの拡張機能でみんな使ったことあるよね？君のサイトはパフォーマンス的にAランクですよ！とか教えてくれるツール。それをPhantom.jsを使ってTravis上でも実行できるように解説してるのが以下のページ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://yslow.org/phantomjs/#travisci-integration&#34;&gt;YSlow - Official Open Source Project Website&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基本的にこの通りにやっていく。さっきの&lt;code&gt;.travis.yml&lt;/code&gt;で指定した&lt;code&gt;npm test&lt;/code&gt;ってのは&lt;code&gt;package.json&lt;/code&gt;
の以下の部分が実行されるということ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/t32k/maple/blob/master/package.json#L15&#34;&gt;maple/package.json at master · t32k/maple&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;で、&lt;code&gt;yslow.sh&lt;/code&gt;を実行するって書いてあるから、yslow.shのファイルは以下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/t32k/maple/blob/master/test/yslow.sh&#34;&gt;maple/test/yslow.sh at master · t32k/maple&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;./node_modules/phantomjs/bin/phantomjs test/yslow.js --info grade --format tap --threshold &#39;{&amp;quot;ycdn&amp;quot;: 10, &amp;quot;yexpires&amp;quot;: 10}&#39; t32k.me/maple/test/fixtures/perf_test.html?${CACHE_CLEAR}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;長ったらしく書いてあってややこいけど、基本的には以下のような構造になってる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;phantomjs yslow.js [オプション] &amp;lt;テストしたいURL&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、重要なオプションである、しきい値の設定も忘れずに。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--threshold &#39;{&amp;quot;ycdn&amp;quot;: 10, &amp;quot;yexpires&amp;quot;: 10}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;単純にテストしたいだけなので『CDN使えよ！』の項目や、gh-pagesでホストしてるのでサーバーの設定とかできないので、キャッシュの項目とか10点でもOKなように（テストが通るように）しておく（もちろん、その他の項目がダメならテストが失敗したよってメールが飛んでくる（飛んでこないようにも設定できる））。&lt;/p&gt;

&lt;p&gt;てな感じで、これでmasterにpushするとその内容をgh-pagesにマージしてホストされたURLをパフォーマンステストするって流れが出来ました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://travis-ci.org/t32k/maple&#34;&gt;Travis CI - Free Hosted Continuous Integration Platform for the Open Source Community&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まぁ今回のテストページとか適当だし、そもそもgh-pagesのホストにデプロイしてる間にtestが実行されちゃって残念な状態にもなってるのであれですけど、雰囲気つかんで貰えれば幸いっす＞ｍ＜&lt;/p&gt;

&lt;h3 id=&#34;参考リソース:e7b29da31b832ac8d2309a565b9ab096&#34;&gt;参考リソース&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://calendar.perfplanet.com/2012/proactive-web-performance-optimization/&#34;&gt;Performance Calendar » Proactive Web Performance Optimization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>WebPagetest in 5 minutes</title>
      <link>http://localhost:1313/mol/log/webpagetest-5-minutes/</link>
      <pubDate>Tue, 05 Nov 2013 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/mol/log/webpagetest-5-minutes/</guid>
      <description>

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;2194dea0233401314f283ee30ec95e6c&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://vimeo.com/78323495&#34;&gt;WebPagetest in 5 minutes // Vimeo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/t32k/webpagetest-in-5-minutes&#34;&gt;WebPagetest in 5 minutes // Speaker Deck&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;webpagetest:1799c7404e18096040cb078b33522743&#34;&gt;WebPagetest&lt;/h2&gt;

&lt;p&gt;2013年10月30日にサイバーエージェントで行われた&lt;a href=&#34;http://frontrend.github.io/events/chrome/&#34;&gt;Frontrend x Chrome Tech Talk Night Extended&lt;/a&gt;でWebPagetestでライトニングトークしてきたのでメモしておく。&lt;/p&gt;

&lt;p&gt;公式サイトにはAddyやJake、Paulの動画も既に公開されている。しかも通訳付きなので参加できなかった方もぜひ見てほしい。&lt;/p&gt;

&lt;p&gt;さて、今回紹介する&lt;a href=&#34;http://www.webpagetest.org/&#34;&gt;WebPagetest&lt;/a&gt;だが、いまいち日本で人気のないようだから紹介してみる。&lt;/p&gt;

&lt;p&gt;私の仕事はWebパフォーマンス改善のタスクを主な業務としている。弊社がリリースしているWebアプリで遅いことが確認されるとその原因を調査する。その時に使うツールがChromeの拡張機能の&lt;a href=&#34;https://chrome.google.com/webstore/detail/pagespeed-insights-by-goo/gplegfbjlmmehdoakndmohflojccocli&#34;&gt;PageSpeed Insights&lt;/a&gt;と、WebPagetestだ。PageSpeedはサクッと調べたい時に使い、WebPagetestを腰を据えてじっくり調べたい時に使う。今回紹介するのはWebPagetestのほうだ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.webpagetest.org/&#34;&gt;WebPagetest - Website Performance and Optimization Test&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WebPagetestを使うには上記のサイトから、調べたいページのURLを入力して『START TEST』のボタンを押すだけだ。しばらくするとテスト結果画面が表示されるのでここからボトルネックを見つける。さまざまなオプションがあるが基本的な使い方はこの通りである。&lt;/p&gt;

&lt;p&gt;WebPagetestはPageSpeed(DevTools)に似たような機能も提供しているが、多くの機能がある。First ByteやStart Render、DOM Elementsなどといった指標を取得することも可能であれば、Waterfall View、Connection View、FilmstripやScripted Testといったことも可能である。ここでは全部紹介しきれないのでWebPagetestの最も素晴らしい機能と言っても過言ではない&lt;strong&gt;Speed Index&lt;/strong&gt;について紹介する。&lt;/p&gt;

&lt;h2 id=&#34;speed-index:1799c7404e18096040cb078b33522743&#34;&gt;Speed Index&lt;/h2&gt;

&lt;p&gt;Speed Indexは、端的に言えば体感速度を指標化したようなものだ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index&#34;&gt;Speed Index - WebPagetest Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;詳しくは上記のドキュメントを読んでもらいたい。簡単に説明するとページのVisual Progressというのがあって、文字通りページがどれだけ描画されているかの進捗度である。スライドのA：青とB：赤のVisual Progressだと、どっちが良いかは自明だろう。どちらも12秒ほどの読み込み時間がかかっているが、青のほうは、1秒の段階で90%ほど描画が完了しているのに対して、赤のほうは11秒くらいまで20%未満のVisual Progressだ。当然、青のほうが体感速度的には早いと感じるであろう。&lt;/p&gt;

&lt;p&gt;Speed Indexというのはこの単位時間辺りのVisual Completeしていない度合いの総和である。つまり、Speed Indexは小さい方はがよりよいということである。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/mol/images/2013/11-06-fig.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;上記の数式の意味は、0秒から読み込みが完了するまでのミリセカンド毎に、1からVisual Completeをひいたものを足した総和ということを意味している。&lt;/p&gt;

&lt;p&gt;これにより、同じ読み込み時間であってもSpeed Indexを見ればどちらが良いのか判断できるようになる。&lt;/p&gt;

&lt;h2 id=&#34;let-s-improve-performance:1799c7404e18096040cb078b33522743&#34;&gt;Let&amp;rsquo;s Improve Performance&lt;/h2&gt;

&lt;p&gt;ということで、試しにこれらのツールを使ってパフォーマンスを改善していく。改善対象サイトは&lt;a href=&#34;http://t32k.me/&#34;&gt;t32k.me&lt;/a&gt;、私のポートフォリオサイト。このページの改善前のPageSpeed Scoreは80点（ちなみに、PageSpeed Insightsの言語設定を日本語にしているとScoreが出ない）。このページのどこが重いのか、軽く見てみるとページ下部にソーシャルウィジェットを発見したので、これを取り除いてみることにする。&lt;/p&gt;

&lt;p&gt;ソーシャルウィジェットを取り除いた改善後のPageSpeed Scoreは93点。やったね、たえちゃん！ってことで素晴らしい改善結果だ。&lt;/p&gt;

&lt;p&gt;しかし、改善前後のWebPagetestの結果を見てみよう。Visual Progressはほぼ変わっていないし、Speed Indexはほぼおなじの3105だorz&amp;hellip;&lt;/p&gt;

&lt;p&gt;ここで言いたいことは、決してソーシャルウィジェットを取り除くことが意味のないことだということではない。事実、ソーシャルウィジェットを読み込んでいる方は当然、総読み込み時間は読み込んでいないものより長くなる。しかし、&lt;strong&gt;体感速度&lt;/strong&gt;の改善という意味では効果のないことかもしれない。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Speed is the second biggest engagement driver on the internet - just after perceived speed.  - &lt;a href=&#34;https://twitter.com/maccaw/status/380385677390516224&#34;&gt;@maccaw&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;この辺りの話題は最近のWeb Performance界隈ではホットな話題だ。PageSpeedで最低限のアドバイス（gzipしろとか）を達成した場合、次はどうすればいいのか？体感速度をどう速めるのか？そしてどうやってそれを計測するのか？&lt;/p&gt;

&lt;p&gt;ちょうど&lt;a href=&#34;http://velocityconf.com/velocityny2013/public/schedule/detail/31344&#34;&gt;Velocity NY 2013で似たような話題を取り扱っていたセッション&lt;/a&gt;があった。そこでSpeed Indexはもちろん紹介されていたし、UserTimingでキーとなるビジュアルを設定し、そのレンダリング速度を計測するといった方法（この場合コンテキスト依存になるので自動化できない..）や、Microsoftの&lt;a href=&#34;http://programming.oreilly.com/2013/10/page-phase-time.html&#34;&gt;PPT&lt;/a&gt;（パワーポイントではない、Page Phaze Time）といった新しい概念もでてきている。要チェックやで！&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://frontrend.github.io/events/chrome/#paul&#34;&gt;Paulのセッション&lt;/a&gt;の最後のほうで、Speed Indexは1000以下にするのは理想だとか言ってたような気がするけど、無理じゃね？&lt;/p&gt;

&lt;h2 id=&#34;private-instance-for-ameba:1799c7404e18096040cb078b33522743&#34;&gt;Private Instance for Ameba&lt;/h2&gt;

&lt;p&gt;あ、そうそうWebPagetestはWebサービスとして使用するのが一般的だが、&lt;a href=&#34;https://github.com/WPO-Foundation/webpagetest&#34;&gt;オープンソース&lt;/a&gt;として公開されていて、自社のネットワーク上に&lt;a href=&#34;https://sites.google.com/a/webpagetest.org/docs/private-instances&#34;&gt;プライベートインスタンス&lt;/a&gt;を置くことも可能だ。なので、UIとかいじりまくりだぜ、ひゃっほーい♪&lt;/p&gt;

&lt;p&gt;我々はWebPagetestを使いテストを自動的に実行し、各種指標を収集するといったことをやっていきたいと考えている。開発中だお(´・ω・｀)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTPリクエストを減らすために【終章】我々には1000msの猶予しか残されていない</title>
      <link>http://localhost:1313/mol/log/reduce-http-requests-one-second/</link>
      <pubDate>Fri, 23 Aug 2013 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/mol/log/reduce-http-requests-one-second/</guid>
      <description>&lt;p&gt;このシリーズはHTTPリクエストの理解を通じてWebパフォーマンスの重要性について考える5章構成になっております。
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-overview/&#34;&gt;【序章】HTTPリクエストは甘え&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-css-sprite/&#34;&gt;【CSS Sprite編】スプライト地獄からの解放&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-webfont/&#34;&gt;【WebFont編】ドラッグ＆ドロップしてコマンド叩いてウェーイ&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-datauri/&#34;&gt;【DataURI編】遅延ロードでレンダリングブロックを回避&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;【終章】我々には1000msの猶予しか残されていない&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
最終日は、我々フロントエンドデベロッパーに課せられた理想と現実のはざまについて冷静と情熱のあいだらへんで考えていきます。まずは下記のブログを読んでくださいませ。
&lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;http://googlewebmastercentral-ja.blogspot.jp/2013/08/making-smartphone-sites-load-fast.html&#34;&gt;スマートフォンサイトの読み込み速度を改善するために : Googleウェブマスターブログ&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
まぁ読まなくてもいいのですが、ここで述べられている重要なことは2つです。
&lt;ol&gt;
    &lt;li&gt;&lt;strong&gt;モバイルの平均読み込み時間は7秒&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;しかし、ユーザーは1秒未満を求めている&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
ということです。&lt;/p&gt;

&lt;p&gt;平均読み込み時間は7秒というのは、&lt;a href=&#34;http://t32k.me/mol/log/no-more-stopwatch/&#34;&gt;Googleアナリティクスのサイトの速度&lt;/a&gt;という機能がありまして、そこから集計、出されたデータによるものです。
&lt;blockquote&gt;入力に対して0.1秒以上1秒未満でコンピューターからの応答があるとき、我々はその間にコンピューターが結果を表示しようとしているように感じる。ユーザーは多少遅いとは思っても、1秒間は進行中の一連の自分の考えに集中したままでいる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.usability.gr.jp/alertbox/20091005_timeframes.html&#34;&gt;http://www.usability.gr.jp/alertbox/20091005_timeframes.html&lt;/a&gt;&lt;/blockquote&gt;
1秒未満というのは、ヤコブ・ニールセン博士というユーザビリティの偉い人がいるのですが、彼のブログで述べられていたことです。要は1秒以内にコンピューターから応答があった場合は、自分がそれをダイレクトに操作している感覚をあたえ、ユーザーエクスペリエンス的によろしいということです。それ以上の時間をかかってしまうとユーザーはストレスを抱え、タスクを放棄しかねないと言っています。&lt;/p&gt;

&lt;p&gt;ということで、今回は1000msに挑戦してみよう！という内容です。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-5292&#34; alt=&#34;life&#34; src=&#34;/static/blog/2013/08/life.png&#34; width=&#34;900&#34; height=&#34;200&#34; /&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34; http://www.webpagetest.org/result/130820_P5_K2H/&#34;&gt; WebPagetest Test Result - Tokyo : t32k.me&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
上記は私のサイトをWebPagetestにかけた結果（TOKYOリージョン、Chrome 3G回線をエミュレート）です。分かりやすくするために読み込むリソースをHTMLだけにしています（Image/CSS/JavaScript読み込んでいません）。しかし、それでも1.7秒近く読み込みに時間がかかっています。&lt;/p&gt;

&lt;p&gt;※ 括弧内の文字はDevToolsでの名称を記述&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-5295&#34; alt=&#34;1stimeline&#34; src=&#34;/static/blog/2013/08/1stimeline.png&#34; width=&#34;824&#34; height=&#34;243&#34; /&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;https://developers.google.com/speed/docs/insights/mobile&#34;&gt;&lt;strong&gt;Mobile Analysis in PageSpeed Insights - PageSpeed Insights&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
さすがに1秒以内に読み込み完了するのは不可能に近いので、レンダリングを1秒以内にしようというのがGoogleさんの教えです。&lt;/p&gt;

&lt;p&gt;ここに書かれていることに、3G回線だとラウンドトリップタイムが約200~300msかかると言われており、仮に200msとした場合、DNS Lookupに1回ラウンドトリップ、TCPコネクション接続に1回ラウンドトリップ、HTTPリクエストとレスポンスで1回ラウンドトリップと合計3回のラウンドトリップで必ず600msは消費します。Serverレスポンスタイムは完全のバックエンドのエンジニアさんの領域なので、 &lt;a href=&#34;http://newrelic.com/&#34;&gt;New Relic&lt;/a&gt;とか使ってボトルネック見つけてね！としか言えません。&lt;/p&gt;

&lt;p&gt;結局、我々フロントエンドに残された時間は200msしかありませんでした(´・ω・`)&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-5296&#34; alt=&#34;ps&#34; src=&#34;/static/blog/2013/08/ps.png&#34; width=&#34;970&#34; height=&#34;430&#34; /&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;https://developers.google.com/speed/pagespeed/insights/&#34;&gt;&lt;strong&gt;PageSpeed Insights &lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
最近リニューアルしたPageSpeed Insightではモバイル版も評価してくれるようになりました。当然モバイル環境はシビアなのでデスクトップ評価と比べて点数は下がってしまいます。そこでは、モバイル版ならではのアドバイスもあり、200msでレンダリングするヒントになります。
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;https://developers.google.com/speed/docs/insights/PrioritizeVisibleContent&#34;&gt;Reduce the size of the above-the-fold content - PageSpeed Insights&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery&#34;&gt;Optimize CSS Delivery - PageSpeed Insights&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
これらが言っていることは、&lt;a href=&#34;http://www.suzukikenichi.com/blog/above-the-fold%E3%81%A8%E3%81%AF/&#34;&gt;above-the-fold&lt;/a&gt; コンテンツを速く見せろと言っています。&lt;/p&gt;

&lt;p&gt;above-the-fold 内にサードパーティなど重いコンテンツがあるのはアウトです。可能な限り軽くしなければなりません。ちなみにHTTPリクエスト・レスポンス、この場合、HTMLが200ms内でダウンロードされる前提ですが、Initial &lt;a href=&#34;http://yougo.ascii.jp/caltar/%E3%82%A6%E3%82%A3%E3%83%B3%E3%83%89%E3%82%A6%E3%82%B5%E3%82%A4%E3%82%BA&#34;&gt;TCP Window Size&lt;/a&gt;が10の場合、&lt;a href=&#34;http://yougo.ascii.jp/caltar/%E3%82%B9%E3%83%AD%E3%83%BC%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%88&#34;&gt;TCPスロースタート&lt;/a&gt;のため1回目のレスポンスで送信できるサイズは&lt;strong&gt;14KB&lt;/strong&gt;までです。それ以上のサイズとなると1回のラウンドトリップで収まりません。ですから、HTMLに重いインライン画像を記述するのはもってのほかであり、CSS/JSだけでなくHTMLのMinifyも考えなければなりません。
&lt;p style=&#34;text-align: center;&#34;&gt;&lt;a href=&#34;http://chimera.labs.oreilly.com/books/1230000000545/ch02.html#SLOW_START&#34;&gt;&lt;img class=&#34;aligncenter size-full wp-image-5310&#34; alt=&#34;tcp&#34; src=&#34;/static/blog/2013/08/tcp.png&#34; width=&#34;800&#34; height=&#34;450&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
HTMLが無事に1回のラウンドトリップで取得できても、残り200ms内にabove-the-foldのレンダリングを完成しなければなりません。ここでCSSファイルが必要となってくるのですが、CSSファイルがダウンロードされるまでレンダリングはブロックされます。あと200msしかないのにHTTPリクエストなんかできません。そう、HTTPリクエストは甘えです。そこで、above-the-foldエリアで必要なスタイルの記述だけをHTML内のstyle要素に記述し、残りのスタイルはlink要素で遅延読み込みするといったことが提案されています。前回の記事でやったようなことですね。&lt;/p&gt;

&lt;p&gt;このように、ここまでやって初めて1000msでレンダリングが完成できるのです。サイトの運用上全てのページでこのような手法を取り入れることは不可能かもしれませんが、求められる理想を実現するにはここまでやらなければならない現実を認識してもらえればと思います。&lt;/p&gt;

&lt;p&gt;初回の記事にHTTPリクエスト甘えと書きましたが、今回の手法は基本的にはHTMLのリクエスト1回しかしていません。そもそも、いかにリクエスト数を減らすか？と考えるのではなく、リクエストさせずにどうするか？と初めから考えといたほうがちょうど良いのかもしれません（それはそれは難しいことですが&amp;hellip;）。&lt;/p&gt;

&lt;p&gt;また、単純に読み込み時間を短縮するのではなく、体感速度をあげるのかといった視点からリソースの優先度を考えたり、あえてCSSを遅延読み込みするなどといったテクニックも必要なんだなと今回記事を書いていて勉強になりました。本当にありがとうございます（誰）&lt;/p&gt;

&lt;p&gt;とはいっても&lt;a href=&#34;http://d.hatena.ne.jp/Jxck/20130723/1374535593&#34;&gt;QUIC, SPDY&lt;/a&gt;や&lt;a href=&#34;http://d.hatena.ne.jp/Jxck/20130815/1376571387&#34;&gt;HTTP 2.0&lt;/a&gt;が普及してくると、また話が違ってきますので、その辺もちゃんとキャッチアップしていかなければなりません。
&lt;p style=&#34;text-align: center;&#34;&gt;&lt;a href=&#34;http://www.unisys.co.jp/services/usability/concept.html&#34;&gt;&lt;img class=&#34;size-full wp-image-5329 aligncenter&#34; title=&#34;The Elements of User Experience　（Web UX 5階層モデル）via 日本ユニシス株式会社&#34; alt=&#34;The Elements of User Experience&#34; src=&#34;/static/blog/2013/08/concept_2.jpg&#34; width=&#34;700&#34; height=&#34;396&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
一連の記事で最も言いたかったのはWebパフォーマンス対策において、これさえやっておけばよい！という銀の弾丸はないということです。HTTPリクエストの削減さえHTTPの仕様が変われば、気にしなくても良いかもしれません。また、レンダリングブロックされているのにもかかわらず読み込み時間だけ見ていて、読み込み時間は速くなったけど、体感速度は遅くなったってゆうことも十分ありえます。&lt;/p&gt;

&lt;p&gt;1000msレンダリングに関してもabove-the-foldのデザインから考え直さないといけませんし、above-the-foldに何を載せるかなどはコンテンツ設計の段階からデベロッパーが関わらないと実現できません。ユーザーエクスペリエンスにおいてWebパフォーマンスを考慮することは、すべての段階、すべての役割の人間が責任をもっていかなければなりません。&lt;/p&gt;

&lt;p&gt;日々の改善はミクロに行いつつも、時には一歩下がって全体から評価してみる。&lt;/p&gt;

&lt;p&gt;なにごともバランスが重要です。
&lt;table border=&#34;0&#34; cellpadding=&#34;5&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/1449344763/warikiru-22/&#34; target=&#34;_blank&#34;&gt;&lt;img alt=&#34;High Performance Browser Networking: What Every Web Developer Should Know About Networking and Web Performance&#34; src=&#34;http://ecx.images-amazon.com/images/I/51qXHNzsmhL._SL160_.jpg&#34; border=&#34;0&#34; /&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;&lt;span&gt;&lt;a href=&#34;http://www.amazon.co.jp/High-Performance-Browser-Networking-Developer/dp/1449344763%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Dwarikiru-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D1449344763&#34; target=&#34;_blank&#34;&gt;High Performance Browser Networking&lt;/a&gt;
Ilya Grigorik &lt;/span&gt;Oreilly &amp;amp; Associates Inc&lt;/p&gt;

&lt;p&gt;2013-08-22&lt;/p&gt;

&lt;p&gt;&lt;a style=&#34;line-height: 19px;&#34; href=&#34;http://www.amazon.co.jp/High-Performance-Browser-Networking-Developer/dp/1449344763%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Dwarikiru-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D1449344763&#34; target=&#34;_blank&#34;&gt;Amazonで詳しく見る&lt;/a&gt;&lt;span style=&#34;line-height: 19px;&#34;&gt;by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34;&gt;G-Tools&lt;/a&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTPリクエストを減らすために【DataURI編】遅延ロードでレンダリングブロックを回避</title>
      <link>http://localhost:1313/mol/log/reduce-http-requests-datauri/</link>
      <pubDate>Thu, 22 Aug 2013 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/mol/log/reduce-http-requests-datauri/</guid>
      <description>&lt;p&gt;このシリーズはHTTPリクエストの理解を通じてWebパフォーマンスの重要性について考える5章構成になっております。
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-overview/&#34;&gt;【序章】HTTPリクエストは甘え&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-css-sprite/&#34;&gt;【CSS Sprite編】スプライト地獄からの解放&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-webfont/&#34;&gt;【WebFont編】ドラッグ＆ドロップしてコマンド叩いてウェーイ&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;【DataURI編】遅延ロードでレンダリングブロックを回避&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-one-second/&#34;&gt;【終章】我々には1000msの猶予しか残されていない&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
4日目は、本ブログでも何回か話題にしているインライン画像についてです。
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/data-uri-scheme/&#34;&gt;データURIスキーム&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/sprite-image-vs-inline-image/&#34;&gt;CSS Sprite画像はDataURI画像にすべきか？ &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
以前の記事で私は以下のように述べましたが、これはいやらしい表現です。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;DataURIの画像は、通常の画像に比べて6倍遅いとかゆう記事もあります
&lt;a href=&#34;http://www.mobify.com/blog/data-uris-are-slow-on-mobile/&#34;&gt;http://www.mobify.com/blog/data-uris-are-slow-on-mobile/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;こうゆう、『xxx倍高速化』、『xxx倍遅い』と言った表現は、わかりやすい反面、本質を見失ってしまう危険性があります。例えば、10秒が1秒になるのも、1秒が0.1秒になるのもどちらも同じく『10倍速くなった』と表現できます。&lt;/p&gt;

&lt;p&gt;似たような例として、毎年のようにブラウザのJavaScriptエンジンがx倍高速化した！といったようなニュースを一度は聞いてるかと思いますが、実体感としては、それほど速くなっていないように感じます。これも結局はブラウザのJS処理というのは何msという単位（あるいはもっと細かい単位かもしれません）での改善なので、そのような文脈での『x倍』というのは、実際は0.数ms程度の違いしかないのかもしれません。&lt;/p&gt;

&lt;p&gt;このように『x倍速くなった・遅くなった』という表現をしているときは、注意が必要です（大人はみんな騙そうとしてきます）！どうゆう文脈での何倍なのか、ちゃんと確認してみましょう。
&amp;gt; In the first condition, the src image attribute was specified to an image location known to be in the browser cache. This is called the binary condition.In the second condition, the src image attribute was specified to a pre- fetched data URI of the same image as in the first condition. This is called the data URI condition.Both conditions used the same image, a 17.8kB PNG. In both conditions, the same image was materialized 5 times. Materialization completion was measured by using the &amp;ldquo;load&amp;rdquo; event of the image object.When the load event for all 5 images fired, the test was marked as “complete” and results were recorded.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.mobify.com/blog/data-uris-are-slow-on-mobile/&#34;&gt;http://www.mobify.com/blog/data-uris-are-slow-on-mobile/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;件のテスト条件は上記のとおりです。まずテストに使われる画像ですが17.8KBのPNGって結構でかいですよ。。ちょっとしたアイコンどころじゃないですよね？そもそも、その大きさの画像でテストする事自体どうなんだって気もします。&lt;/p&gt;

&lt;p&gt;次に、画像のloadイベントが発生した時を完了と見なしています、そして通常の画像パスでの読み込みはブラウザキャッシュがある状態としています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.mobify.com/blog/data-uris-are-slow-on-mobile/&#34;&gt;&lt;img class=&#34;aligncenter size-large wp-image-5194&#34; alt=&#34;image_0&#34; src=&#34;/static/blog/2013/08/image_0.png&#34; width=&#34;540&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;で、結果が上記のグラフです、Android2系はほっといてAndroid4系、iOS6の差を見てみるとだいたい100ms ~ 150msくらいです。この差をどう捉えるかですね。実際のケースで考えれば、17.6KBの画像を3G回線でHTTPリクエストすればラウンドトリップだけで200ms以上はかかるでしょうし、また画像リクエストで同時接続数の1つを失ってしまい、後続のリソースのブロッキングをする可能性も出てくると考えれば、 150msくらい許容範囲ではないでしょうか？&lt;/p&gt;

&lt;p&gt;許容範囲であるかないかは、各々の状況というのがあると思うので各人で判断してもられば良いのですが、少なくとも『DataURI？あ、6倍遅いからダメ！』って短絡的に片付けるの良くないかと思います。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;では、インライン画像ってどうゆうときに使うのでしょうか？使わざるを得ないのでしょうか？&lt;/p&gt;

&lt;p&gt;HTTPリクエストを減らすという観点から言えば、大抵のものは前々回で話したようにCSSスプライトにしてしまえばよいのです、また、単純な図形・アイコンでカラーバリエーションがあるようなものであればWebフォントにすればよいでしょう。&lt;/p&gt;

&lt;p&gt;しかし世の中そんなに甘くありません。下記のようなものはCSSスプライトできません。
&lt;ul&gt;
    &lt;li&gt;&lt;span class=&#34;code&#34;&gt;border-image&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&#34;code&#34;&gt;background-image&lt;/span&gt;(縦横リピート)&lt;/li&gt;
&lt;/ul&gt;
まぁ、こうゆうのですよね。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-5196&#34; alt=&#34;ss&#34; src=&#34;/static/blog/2013/08/ss1.png&#34; width=&#34;556&#34; height=&#34;154&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ボタンの文字が決め打ちだったり、幅が決まってたりする場合は単純にその画像をスプライトすればよいのですが、そうでもない場合は&lt;span class=&#34;code&#34;&gt;border-image&lt;/span&gt;にしたほうが、都合が良いです。もちろん左端と右端と中央で画像を分けて各背景画像で対応するのもいいけど、やっぱり&lt;span class=&#34;code&#34;&gt;border-image&lt;/span&gt;がなにかと都合が良いです。&lt;/p&gt;

&lt;p&gt;あと背景画像は、X軸、Y軸リピートならなんとかできるけど、縦横リピートになるとCSSスプライトではどうしようもできないです。でも、全体の背景にテクスチャ画像を貼るのもよくある表現です。&lt;/p&gt;

&lt;p&gt;ということで、DataURI使いたいと思います。インライン画像を考える上で重要なのは以下の3つです。
&lt;ul&gt;
    &lt;li&gt;インライン画像はリクエストを発生させない&lt;/li&gt;
    &lt;li&gt;だがファイルサイズが重くなる&lt;/li&gt;
    &lt;li&gt;CSSファイルに含めるとレンダリングブロックに繋がる可能性あり&lt;/li&gt;
&lt;/ul&gt;
ちなみにCompassだと下記のような関数を使うとbase64エンコードしてくれます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.border{
    border-image: inline-image(&amp;quot;/path/to/border-image.png&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://compass-style.org/reference/compass/helpers/inline-data/&#34;&gt;Compass Inline Data Helpers | Compass Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
では、3つめのインライン画像をCSSファイルに含んだ時のレンダリングブロック回避について考えて行きましょう。&lt;/p&gt;

&lt;p&gt;それで、通常のスタイルとインライン画像の指定をしたCSSを分けてみました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;css/app.css&amp;quot;&amp;gt;
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;css/base64.css&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.github.io/test/include-datauri/block.html&#34;&gt;Block : Include DataURI Source &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
感覚的には、こういったマークアップをしてしまいがちですが、これでも結局、インライン画像を含んだ重いbase64.cssが読み込まれるまでレンダリングが始まりません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;
(function(d){
  var c = d.createElement(&#39;link&#39;);
  c.rel = &#39;stylesheet&#39;;
  c.href = &#39;css/base64.css&#39;;
  var s = d.getElementsByTagName(&#39;script&#39;)[0];
  s.parentNode.insertBefore(c, s);
})(document);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.github.io/test/include-datauri/&#34;&gt;Defer : Include DataURI Source &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
ですので、遅延読み込みしたのが上記です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.webpagetest.org/video/compare.php?tests=130815_WY_66F,130815_9R_66G&#34;&gt;&lt;img class=&#34;aligncenter size-full wp-image-5198&#34; alt=&#34;ss1&#34; src=&#34;/static/blog/2013/08/ss11.png&#34; width=&#34;840&#34; height=&#34;365&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.webpagetest.org/video/compare.php?tests=130815_WY_66F,130815_9R_66G&#34;&gt;WebPagetest - Visual Comparison&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;BlockとDeferをVideo Comparisonした結果が上記です。Video Comparisonのテスト条件上、Dulles, VA - IE 9の環境でしかテストできませんので、border-imageは対応していないため表示されていません、あしからず。遅延読み込みしたのが、0.2秒でレンダリングが始まっているのに対して、通常読み込みは0.5秒で完成しています。&lt;/p&gt;

&lt;p&gt;差を分かりやすくするために、base64.cssにはコメントアウトした長ーい文字列を記述しファイルサイズを増加させています。
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://www.webpagetest.org/result/130815_HC_66Z/&#34;&gt;Defer : WebPagetest Test Result - Tokyo&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://www.webpagetest.org/result/130817_22_D68/&#34;&gt;Block : WebPagetest Test Result - Tokyo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
Chrome,3G回線でテストした詳細な結果でも、遅延読み込みしている方の&lt;strong&gt;Start Renderは1.786s&lt;/strong&gt;に対して、通常読み込みは&lt;strong&gt;3.564s&lt;/strong&gt;とかなり違う結果になりました。もちろん遅延読み込みしている分、最終的なFully Loadedは遅くなります。&lt;/p&gt;

&lt;p&gt;以上のようにすれば、懸念していたインライン画像を含む重いCSSによるレンダリングブロックを回避できるかと思います。&lt;/p&gt;

&lt;p&gt;遅延読み込みが銀の弾丸かと言えば、とうてい、そんな上等なものでありません。苦肉の策感がにじみ出ています。今回のようなborder-imageを使ったボタンも高さや幅を限定してパターン数を絞ればCSSスプライトでまかなえることも可能ですし、背景画像もno-repeatにできればCSSスプライトで収まる場合もあります。そのようなことを考慮した上で、はじめて遅延読み込みするといった手段を採用すべきです。&lt;/p&gt;

&lt;p&gt;なにごともバランスが重要です。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTPリクエストを減らすために【WebFont編】ドラッグ＆ドロップしてコマンド叩いてウェーイ</title>
      <link>http://localhost:1313/mol/log/reduce-http-requests-webfont/</link>
      <pubDate>Wed, 21 Aug 2013 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/mol/log/reduce-http-requests-webfont/</guid>
      <description>&lt;p&gt;このシリーズはHTTPリクエストの理解を通じてWebパフォーマンスの重要性について考える5章構成になっております。
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-overview/&#34;&gt;【序章】HTTPリクエストは甘え&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-css-sprite/&#34;&gt;【CSS Sprite編】スプライト地獄からの解放&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;【WebFont編】ドラッグ＆ドロップしてコマンド叩いてウェーイ&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-datauri/&#34;&gt;【DataURI編】遅延ロードでレンダリングブロックを回避&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-one-second/&#34;&gt;【終章】我々には1000msの猶予しか残されていない&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
3日目は、スマホ環境であればHTTPリクエストを減らすためにWebフォントの採用について考慮しても、やぶさかではないでしょう。&lt;/p&gt;

&lt;p&gt;まずは下記の画像をご覧頂きたい。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-5274&#34; alt=&#34;arrows&#34; src=&#34;/static/blog/2013/08/arrows.png&#34; width=&#34;607&#34; height=&#34;30&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これは私がプロジェクトで使用していたスプライト画像ですが（実際は縦にして使用）、このような単純な形状、単色のアイコンであれば、Webフォント化したほうがなにかと都合がよいです。&lt;/p&gt;

&lt;p&gt;このスプライトであれば、カラー×矢印の向き×シャドウのありなしでパターンが増えていく可能性があり、スプライトすれば1リクエストで収まりますが、それでも画像が肥大化していけば、&lt;strong&gt;Receiving &lt;/strong&gt;が無視できない状況になっていきます。&lt;/p&gt;

&lt;p&gt;そこでWebフォント化すれば、色は自由に変更できますし、フォントなので&lt;span class=&#34;code&#34;&gt;text-shadow&lt;/span&gt;で影を当てることもできますし、&lt;span class=&#34;code&#34;&gt;font-size&lt;/span&gt;で大きさも変更でき柔軟に対応することができます。&lt;/p&gt;

&lt;p&gt;それではWebフォントって一体どうやって作るのでしょうか？高いフォント作成アプリケーションを購入しなければならないのでしょうか？オンライン作成ツールもあるようですが、毎回新しいアイコン追加の度にそのツールのサイトを訪問しなければならないのでしょうか？
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://icomoon.io/&#34;&gt; IcoMoon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
以前は上記のオンラインツールを使ってましたが、やはり更新対応を考えるとめんどくさかったです。ということで、&lt;a href=&#34;https://github.com/t32k/maple&#34;&gt;Mapleプロジェクト&lt;/a&gt;では&lt;a href=&#34;https://github.com/sapegin/grunt-webfont&#34;&gt;&lt;strong&gt;grunt-webfont&lt;/strong&gt;&lt;/a&gt;を導入しました。&lt;/p&gt;

&lt;p&gt;ということで、前回の記事を見ながら、&lt;span class=&#34;code&#34;&gt;grunt-init maple&lt;/span&gt;しましょう^_^&lt;/p&gt;

&lt;p&gt;必要環境として以下のものインストールしておきましょう 。
&lt;a href=&#34;http://brew.sh/&#34;&gt;Homebrew&lt;/a&gt;も入っていなければインストールしておきましょう。
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;$ brew install fontforge ttfautohint
$ brew install &lt;a href=&#34;https://raw.github.com/sapegin/grunt-webfont/master/Formula/sfnt2woff.rb&#34;&gt;https://raw.github.com/sapegin/grunt-webfont/master/Formula/sfnt2woff.rb&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;
あと事前に必要になるのは、フォントの元となるSVGファイルです。&lt;a href=&#34;https://github.com/cognitom/symbols&#34;&gt;SVGファイルを作る上で便利なテンプレート&lt;/a&gt;があるのでそれを拝借してきましょう。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter  wp-image-5163&#34; alt=&#34;arrow&#34; src=&#34;/static/blog/2013/07/c2eef1dbac4917459d28818432f9c6b8.png&#34; width=&#34;640&#34; /&gt;&lt;/p&gt;

&lt;p&gt;テンプレートを使ってMapleでは上記のような.aiを作成しました。&lt;a href=&#34;http://iconmonstr.com/&#34;&gt;iconmonstr&lt;/a&gt;にはいろいろ使い勝手がいいアイコンが無料で配布されていますので、ここから必要な物をとってくるのもいいでしょう。ここからIllustratorでアートボード別に書きだしてSVGファイルとして保存します。要注意なのはこのアートボードの空白部分も含めてSVGファイルなので気をつけてください。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-5282&#34; alt=&#34;fontdir&#34; src=&#34;/static/blog/2013/08/fontdir.png&#34; width=&#34;675&#34; height=&#34;387&#34; /&gt;&lt;/p&gt;

&lt;p&gt;基本的にこの部分はデザイナーさんにやってもらえればよいことなので、フロントエンドデベロッパーは完成したSVGファイルを、&lt;span class=&#34;code&#34;&gt;/src/files/font/svg&lt;/span&gt; ディレクトリに投げ込んでコマンド打つだけです。
&lt;pre&gt;&lt;code&gt;$ grunt webfont
Running &amp;ldquo;webfont:dist&amp;rdquo; (webfont) task
Font &amp;lsquo;myfont-b5fd89266afbbfbfc281a0ce9a5bf50e&amp;rsquo; with 13 glyphs created.&lt;/code&gt;&lt;/pre&gt;
で、&lt;span class=&#34;code&#34;&gt;/src/tools/&lt;/span&gt;で&lt;span class=&#34;code&#34;&gt;grunt webfont&lt;/span&gt;を実行すれば上記のようなログなとともに、&lt;strong&gt;.woff&lt;/strong&gt;と&lt;strong&gt;.ttf&lt;/strong&gt;と_myfont.scssが作成されます。
&lt;pre&gt;&lt;code&gt;// _setting.scss
//&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-
@import &amp;ldquo;../vendors/myfont&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;// _myfont.scss
.icon-hoge:before {
content:&amp;rdquo;\f100&amp;rdquo;;
}&lt;/code&gt;&lt;/pre&gt;
_myfont.scssは_setting.scssで&lt;span class=&#34;code&#34;&gt;@import&lt;/span&gt;されていますので、特にCSSをいじることはありません。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-5170&#34; alt=&#34;icon&#34; src=&#34;/static/blog/2013/08/icon.png&#34; width=&#34;640&#34; height=&#34;250&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上記のように、&lt;span class=&#34;code&#34;&gt;.icon-{SVGファイル名}&lt;/span&gt;のクラスを当てれば、すぐさま使えます。&lt;/p&gt;

&lt;p&gt;Webフォント使えば、CSSスプライトに頼らなくても大丈夫だー＼(-o-)／って使う前は思っていましたが、やはり単純な表現に限定されます。グラデーションカラーかつシャドウ有りや、部分的に色を変えるなどはWebフォントでは無理がありますので、そこはCSSスプライトを採用するか、デザインを少し調整してWebフォント化するかはデザイナーと相談しましょう。&lt;/p&gt;

&lt;p&gt;また、Webフォントも複数のアイコンのリクエストをまとめることができますが、Webフォント自体のリクエストが必要になるので、フォントがダウンロードされるまでは、当たり前ですが表示されません。そのため、数種類のパターンで収まることがわかっていればWebフォント化可能でもCSSスプライトでまとめることも考慮すべきです。&lt;/p&gt;

&lt;p&gt;なにごともバランスが重要です。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTPリクエストを減らすために【CSS Sprite編】スプライト地獄からの解放</title>
      <link>http://localhost:1313/mol/log/reduce-http-requests-css-sprite/</link>
      <pubDate>Tue, 20 Aug 2013 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/mol/log/reduce-http-requests-css-sprite/</guid>
      <description>&lt;p&gt;このシリーズはHTTPリクエストの理解を通じてWebパフォーマンスの重要性について考える5章構成になっております。
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-overview/&#34;&gt;【序章】HTTPリクエストは甘え&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;【CSS Sprite編】スプライト地獄からの解放&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-webfont/&#34;&gt;【WebFont編】ドラッグ＆ドロップしてコマンド叩いてウェーイ&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-datauri/&#34;&gt;【DataURI編】遅延ロードでレンダリングブロックを回避&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-one-second/&#34;&gt;【終章】我々には1000msの猶予しか残されていない&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
2日目は、HTTPリクエストを減らす最もポピュラーな手法、CSSスプライトについて説明します。&lt;/p&gt;

&lt;p&gt;まずは動画をご覧頂きましょう。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;//www.youtube.com/embed/s__XwfwxMW8&#34; height=&#34;360&#34; width=&#34;640&#34; allowfullscreen=&#34;&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://www.webpagetest.org/result/130816_VR_9E8/&#34;&gt;img要素読み込み | WebPagetest Test Result&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://www.webpagetest.org/result/130816_J6_9EG/&#34;&gt;CSS Sprite読み込み | WebPagetest Test Result&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
左が30個のアイコン画像をひとつ、ひとつimg要素として読み込んでいます。右は１つの背景画像（CSSスプライト）として読み込んでいます。この場合、表示完了までの差はCSSスプライトのほうが圧倒的に速いです。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-5249&#34; alt=&#34;waterfall&#34; src=&#34;/static/blog/2013/08/waterfall.png&#34; width=&#34;885&#34; height=&#34;552&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これは前回のHTTPリクエストの仕組みを理解していれば当然のことといえます。つまり、ホスト名ごとの同時接続数やRTTが関係しています。上記のimg画像読み込みのウォーターフォールチャートを確認してみれば一目瞭然です。CSSスプライトすることで一つの画像ファイルサイズは重くなりますが、この場合、重要なのは&lt;strong&gt;Receiving&lt;/strong&gt;の時間というより&lt;strong&gt;Waiting&lt;/strong&gt;の時間なので、結果的にアイコン表示までの時間を短縮できています。&lt;/p&gt;

&lt;p&gt;CSSスプライトの仕組み自体は簡単もので、任意の要素の中で背景画像の位置を調整して表示しています。実際に表示されるのは要素で指定したwidth/heightの分だけなので、あたかも1個の独立した画像のように見えます。&lt;/p&gt;

&lt;p&gt;CSSスプライトは非常に便利ですが、問題点もあります。スプライトのジレンマというのがあり、ページ数、保守性、最適化の観点から評価します。スプライトをする上でこの3つの中から2つしかとれません。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-5245&#34; alt=&#34;dilemma&#34; src=&#34;/static/blog/2013/08/dilemma.jpg&#34; width=&#34;470&#34; height=&#34;260&#34; /&gt;&lt;/p&gt;

&lt;p&gt;例えば、多くのページ数を保守性を保ちながらスプライトすると、最適化はちょっとあきらめなければいけません。また、多くのページ数を可能な限り最適化すれば保守性はあきらめなければなりません。また、保守性を意識しつつ最適化すれば、適用できるページ数は少なくなってしまいます。&lt;/p&gt;

&lt;p&gt;考えてもみてください、画像の変更があるたびにPhotoshopを開いて、画像を置き直して、その位置をルーラーで割り出す。それがRetina画像であれば、実際の&lt;span class=&#34;code&#34;&gt;background-position&lt;/span&gt;サイズから半分にしないといけません。気の遠くなるような面倒くさいタスクです。面倒くさくなくてもヒューマンエラーというのは起こるもので、単純な割り算（この場合Retina対策として背景位置を半分にする）でも、何回も繰り返せば、ミスはあります。そしてそのミスに気づかず数時間ロスをすることもままです。&lt;/p&gt;

&lt;p&gt;もう、なんというかCSSスプライトが嫌すぎてデザイナーと喧嘩することもしばしば。これでは精神衛生上よくありません。&lt;/p&gt;

&lt;p&gt;そこでそのめんどくさいタスクSass/CompassのMixinにやってもらおうと思います。&lt;a href=&#34;http://t32k.me/mol/log/spriting-with-compass/&#34;&gt;以前に書いた記事&lt;/a&gt;から変更しています。
&lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/t32k/maple#mixins&#34;&gt;t32k/maple/mixin&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
まず、Mixinの説明する前に&lt;a href=&#34;https://github.com/t32k/maple&#34;&gt;Mapleプロジェクト&lt;/a&gt;をダウンロードしてきます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/t32k/maple#-installation&#34;&gt;Node.js, Ruby, Sass, Compassがインストール&lt;/a&gt;されていること前提。&lt;/p&gt;

&lt;p&gt;まずは&lt;a href=&#34;https://github.com/t32k/grunt-init-maple&#34;&gt;grunt-init-maple&lt;/a&gt;をインストールしておきましょう。
&lt;pre&gt;&lt;code&gt;$ npm install -g grunt-cli
$ npm install -g grunt-init
$ git clone &lt;a href=&#34;https://github.com/t32k/grunt-init-maple.git&#34;&gt;https://github.com/t32k/grunt-init-maple.git&lt;/a&gt; ~/.grunt-init/maple &amp;ndash;recursive
&lt;/code&gt;&lt;/pre&gt;
&lt;span class=&#34;code&#34;&gt;grunt-init maple&lt;/span&gt;を実行すると以下のようにMapleプロジェクトに必要なファイルがスキャフォルディングされ（落ちてき）ます。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-5154&#34; alt=&#34;grunt-init&#34; src=&#34;/static/blog/2013/08/grunt-init.gif&#34; width=&#34;640&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;p&gt;落ちてきたら、&lt;span class=&#34;code&#34;&gt;/src/tools&lt;/span&gt;（Gruntfile, package.jsonがある場所）に移動し、必要なGruntプラグインをインストール（&lt;span class=&#34;code&#34;&gt;npm install&lt;/span&gt;）しておきます。これで下準備はOKです。&lt;/p&gt;

&lt;p&gt;その場所で&lt;span class=&#34;code&#34;&gt;grunt develop&lt;/span&gt;して、&lt;span class=&#34;code&#34;&gt;&lt;a href=&#34;http://localhost:8080/components/&#34;&gt;http://localhost:8080/components/&lt;/a&gt;&lt;/span&gt;を見に行きましょう。そこにスプライトした画像が表示されていますからDevToolsなどで確認してみましょう。
&lt;pre&gt;&lt;code&gt;.sprt-a {
  background-image: url(/files/img/sprite/tabs-s3217a038c5.png);
  background-repeat: no-repeat;
  background-size: 120px 25px;
}
.sprt-a-bird1 {
  width: 30px;
  height: 25px;
  background-position: 0 0;
}
.sprt-a-bird2 {
  width: 30px;
  height: 25px;
  background-position: -30px 0;
&amp;hellip;
&lt;/code&gt;&lt;/pre&gt;
上記のようなスタイルが当たっているかと思います。コレ自体はCSSなので普通のCSSスプライトのコードです。
&lt;pre&gt;&lt;code&gt;$map-tabs: sprite-map(&amp;ldquo;/files/img/sprite/tabs/*.png&amp;rdquo;, $date: horizontal);&lt;/p&gt;

&lt;p&gt;// 共通クラス
.sprt-a { @include sprite(parent, $map-tabs); }
// 個別クラス
.sprt-a-bird1 { @include sprite(child, $map-tabs, bird1); }
.sprt-a-bird2 { @include sprite(child, $map-tabs, bird2); }
.sprt-a-bird3 { @include sprite(child, $map-tabs, bird3); }
.sprt-a-bird4 { @include sprite(child, $map-tabs, bird4); }&lt;/code&gt;&lt;/pre&gt;
実際のSassコードは上記です。特に、煩わしい&lt;span class=&#34;code&#34;&gt;background-position&lt;/span&gt;が書いてないことが分かります。各画像の&lt;span class=&#34;code&#34;&gt;background-position&lt;/span&gt;の算出は&lt;span class=&#34;code&#34;&gt;sprite&lt;/span&gt;というMixinで定義してありますので、使う人は画像の位置をいちいちPhotoshopで測るといったことをしなくてもよくなります。&lt;/p&gt;

&lt;p&gt;詳しく説明していきますと、&lt;span class=&#34;code&#34;&gt;$map-tabs:&lt;/span&gt;で、スプライトしたい画像を指定しています。imgディレクトリ配下にspriteディレクトリを作ってそこにスプライト画像をおいておけば、普通の画像と区別できて便利です。このディレクトリの中に、スプライト前の１個１々独立した画像が入っています。これらの画像をCompassがまとめてくれるのです。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-5246&#34; alt=&#34;dir&#34; src=&#34;/static/blog/2013/08/dir.jpg&#34; width=&#34;660&#34; height=&#34;420&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;code&#34;&gt;.sprt-a&lt;/span&gt;で指定してある。&lt;span class=&#34;code&#34;&gt;@include sprite(parent, $map-tabs)&lt;/span&gt;は、各スプライト画像の共通プロパティを吐き出す用に指定します。各スプライトのclassすべてに同じ&lt;span class=&#34;code&#34;&gt;background-image&lt;/span&gt;のプロパティを吐き出されては冗長ですからね。&lt;/p&gt;

&lt;p&gt;parentは親（共通）classであることを示し、$map-tabsは展開するスプライト画像を指定しています。&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;code&#34;&gt;.sprt-a-bird1&lt;/span&gt;のchildは子(個別)classであることを示し、$map-tabsは上記と同じく、第3引数で、そのスプライト画像で使いたい画像名を指定しています。ここではbird1を指定していますので、&lt;span class=&#34;code&#34;&gt;/files/img/sprite/tabs/bird1.png&lt;/span&gt;の&lt;span class=&#34;code&#34;&gt;background-position&lt;/span&gt;がはきだされるようになります。
&lt;pre&gt;&lt;code&gt;// 個別クラスにwidth/height吐き出さない場合
.sprt-a { @include sprite(parent, $map-tabs, bird1, true); }
.sprt-a-bird1 { @include sprite(child, $map-tabs, bird1, true); }&lt;/code&gt;&lt;/pre&gt;
もし、&lt;strong&gt;個別のスプライト画像が全て同じ場合&lt;/strong&gt;、第4引数に&lt;span class=&#34;code&#34;&gt;true&lt;/span&gt;をつけて&lt;span class=&#34;code&#34;&gt;@include&lt;/span&gt;すれば、個別クラスにはサイズ指定されず、共通クラスにwidth/heightが記述されて、コード量を節約することができます。&lt;/p&gt;

&lt;p&gt;このようにMixinを活用出来れば、フロントエンドデベロッパーはデザイナーからもらったアイコン画像を任意のディレクトリに放り込んで、コマンドを打つだけでスプライト画像を生成することができます。冷えきったデザイナーとの関係にも終止符をうてます。&lt;/p&gt;

&lt;p&gt;また、Compassで生成したPNG画像は減色やメタ情報のストリップなどされていませんので、そのままではデプロイしてしまうのはいかんともしがたいです。通常、&lt;a href=&#34;http://imageoptim.com/&#34;&gt;ImageOptim.app&lt;/a&gt;などのツールで画像を最適化する必要性がありますが、ドラッグ&amp;amp;ドロップもめんどくさいので、というか忘れるので、Gruntタスクに&lt;a href=&#34;https://github.com/JamieMason/grunt-imageoptim&#34;&gt;grunt-imageoptim&lt;/a&gt;というものを組み込みました。これはなんてことのないタスクで指定した画像を自動的に（imageOptim.appが立ち上がって）最適化してくれます。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-5159&#34; alt=&#34;build&#34; src=&#34;/static/blog/2013/08/build.gif&#34; width=&#34;640&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Mapleプロジェクトでは、&lt;span class=&#34;code&#34;&gt;grunt build&lt;/span&gt;でCSSがlintされ、Compassでコンパイルされ、CSSがminifyされ、画像がimageOptimされるというタスクを組んでありますので、忘れることもありません。&lt;/p&gt;

&lt;p&gt;Sass/Compassを使えばスプライトのジレンマから開放されます。しかし、なんでもかんでもスプライト画像に詰め込んでしまえば、今度はRTTではなくDLタイムが問題になってきます。&lt;/p&gt;

&lt;p&gt;CSSスプライトに取り込む前に、
&lt;ul&gt;
    &lt;li&gt;本当に画像で表現しなければいけないのか？&lt;/li&gt;
    &lt;li&gt;CSSで表現できないのか？&lt;/li&gt;
    &lt;li&gt;どこを調整したらCSSだけで表現できるようになるのか？&lt;/li&gt;
&lt;/ul&gt;
などデザイナーさんと相談してみましょう。&lt;/p&gt;

&lt;p&gt;なにごともバランスが重要です。
&lt;table border=&#34;0&#34; cellpadding=&#34;5&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873114462/warikiru-22/ref=nosim/&#34; target=&#34;_blank&#34;&gt;&lt;img alt=&#34;続・ハイパフォーマンスWebサイト ―ウェブ高速化のベストプラクティス&#34; src=&#34;http://ecx.images-amazon.com/images/I/51GQNCMJsZL._SL160_.jpg&#34; border=&#34;0&#34; /&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;&lt;span&gt;&lt;a href=&#34;http://www.amazon.co.jp/%E7%B6%9A%E3%83%BB%E3%83%8F%E3%82%A4%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9Web%E3%82%B5%E3%82%A4%E3%83%88-%E2%80%95%E3%82%A6%E3%82%A7%E3%83%96%E9%AB%98%E9%80%9F%E5%8C%96%E3%81%AE%E3%83%99%E3%82%B9%E3%83%88%E3%83%97%E3%83%A9%E3%82%AF%E3%83%86%E3%82%A3%E3%82%B9-Steve-Souders/dp/4873114462%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Dwarikiru-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4873114462&#34; target=&#34;_blank&#34;&gt;続・ハイパフォーマンスWebサイト&lt;/a&gt;&lt;img style=&#34;border: none;&#34; alt=&#34;&#34; src=&#34;http://www.assoc-amazon.jp/e/ir?t=warikiru-22&amp;amp;l=ur2&amp;amp;o=9&#34; width=&#34;1&#34; height=&#34;1&#34; /&gt;
Steve Souders &lt;/span&gt;&lt;span&gt;&lt;span&gt;武舎 広幸&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;オライリージャパン 2010-04-10&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.amazon.co.jp/%E7%B6%9A%E3%83%BB%E3%83%8F%E3%82%A4%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9Web%E3%82%B5%E3%82%A4%E3%83%88-%E2%80%95%E3%82%A6%E3%82%A7%E3%83%96%E9%AB%98%E9%80%9F%E5%8C%96%E3%81%AE%E3%83%99%E3%82%B9%E3%83%88%E3%83%97%E3%83%A9%E3%82%AF%E3%83%86%E3%82%A3%E3%82%B9-Steve-Souders/dp/4873114462%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Dwarikiru-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4873114462&#34; target=&#34;_blank&#34;&gt;Amazonで詳しく見る&lt;/a&gt; &lt;span&gt;by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34;&gt;G-Tools&lt;/a&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTPリクエストを減らすために【序章】HTTPリクエストは甘え</title>
      <link>http://localhost:1313/mol/log/reduce-http-requests-overview/</link>
      <pubDate>Mon, 19 Aug 2013 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/mol/log/reduce-http-requests-overview/</guid>
      <description>&lt;p&gt;このシリーズはHTTPリクエストの理解を通じてWebパフォーマンスの重要性について考える5章構成になっております。
&lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;【序章】HTTPリクエストは甘え&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-css-sprite/&#34;&gt;【CSS Sprite編】スプライト地獄からの解放&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-webfont/&#34;&gt;【WebFont編】ドラッグ＆ドロップしてコマンド叩いてウェーイ&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-datauri/&#34;&gt;【DataURI編】遅延ロードでレンダリングブロックを回避&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-one-second/&#34;&gt;【終章】我々には1000msの猶予しか残されていない&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
1日目は、HTTPリクエストの概要について説明します。&lt;/p&gt;

&lt;p&gt;例えに、私のポートフォリオページ（&lt;a href=&#34;http://t32k.me/&#34;&gt;http://t32k.me/&lt;/a&gt;）が表示されるまでの流れを見て行きましょう。まず、ブラウザのURLバーにt32k.meと打ち込んで、アクセスします。検索からでも方法はなんでもよいのですが、そのページを見に行くということは、結局はt32k.meに対してhttpスキームでリクエストするということを意味しています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.slideshare.net/t32k/ss-15915114/27&#34;&gt;&lt;img class=&#34;size-full wp-image-5128 aligncenter&#34; alt=&#34;HTTPリクエストの中身&#34; src=&#34;/static/blog/2013/08/requests.gif&#34; width=&#34;640&#34; height=&#34;400&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;クライアントであるブラウザは、入力されたURLを判断して、リソース（この場合HTMLファイル）を要求しにいきます。このとき、t32k.meというドメインはあくまで人間が覚えやすいように考えられた仕組みなので、ブラウザはこれだけではリソースに到達出来ません。そこでドメインをIPアドレス（192.0.2.0とかそうゆうの）に正引き（変換）する必要性があります。この作業を&lt;b&gt;DNS Lookup&lt;/b&gt;（名前解決）といいます。たいてい、ISPのDNSサーバーに問い合わせたりして解決します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DNS - Domain Name System&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;サーバーのIPアドレスが分かったので今度は、サーバーさんに接続しに行きます。クライアントは『サーバーさんいる？』と聞き、『サーバーはいるで！』と答えます。このやりとりを&lt;strong&gt;Connecting&lt;/strong&gt;といいソケット接続が確立します。なぜ一発目からリクエストを通さないのかというと、それだと受け手の状況がわからないので通信の信頼性が担保されないからです。詳しくはTCPの&lt;a href=&#34;http://ja.wikipedia.org/wiki/3%E3%82%A6%E3%82%A7%E3%82%A4%E3%83%BB%E3%83%8F%E3%83%B3%E3%83%89%E3%82%B7%E3%82%A7%E3%82%A4%E3%82%AF&#34;&gt;スリーウェイハンドシェイク&lt;/a&gt;という仕組みを調べてみてください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TCP - Transmission Control Protocol&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;サーバーとの接続が確立したので、ここでやっとHTTPリクエスト、つまりここでは、&lt;span class=&#34;code&#34;&gt;&lt;a href=&#34;http://t32k.me/index.html&#34;&gt;http://t32k.me/index.html&lt;/a&gt;&lt;/span&gt;を要求します。動的ファイルだったらファイル生成などプロセスが走ります。それで見つけた・生成したファイルをクライアントに送信します。送信した最初のパケットがクライアントに届いた時点までが、&lt;strong&gt;Waiting&lt;/strong&gt;の時間になります。&lt;/p&gt;

&lt;p&gt;そして、最後のパケットが送り終えた時点までが、&lt;strong&gt;Receiving&lt;/strong&gt;の時間になります。ここがいわゆるファイルのダウンロード時間にかかる時間です。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-5134&#34; alt=&#34;network&#34; src=&#34;/static/blog/2013/08/network1.png&#34; width=&#34;639&#34; height=&#34;220&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ちなみに、これらのタイミングにかかる時間は、&lt;a href=&#34;https://developers.google.com/chrome-developer-tools/docs/network?hl=ja&#34;&gt;Google ChromeのDeveloper ToolsのNetworkパネル&lt;/a&gt;のTimingタブで確認出来ます。&lt;/p&gt;

&lt;p&gt;このHTTPリクエストの中身を確認して重要なのは、クライアントとサーバーとのやりとりにかかる時間、ラウンドトリップタイム(RTT)と、リソースのダウンロードにかかる時間（DL）です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RTT - Round Trip Time&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;t32k.meのネットワークにかかる情報をまとめたHARファイルに保存して（DevToolsのネットワークパネル右クリックで保存）、&lt;a href=&#34;http://www.softwareishard.com/har/viewer/&#34;&gt;HAR Viewr&lt;/a&gt;で見たものが以下です。分かりやすくするために、3G回線でエミュレートした結果を表示しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HAR - &lt;a href=&#34;http://www.softwareishard.com/blog/har-12-spec/&#34;&gt;HTTP Archive format&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-5140&#34; alt=&#34;har&#34; src=&#34;/static/blog/2013/08/har.png&#34; width=&#34;977&#34; height=&#34;366&#34; /&gt;&lt;/p&gt;

&lt;p&gt;どうでしょう、見た感じで、紫色のバーが多いことに気づきますよね。つまりWatitingに多くの時間がかかっていることが理解出来ます。これは、単純にサーバーの処理が遅くて時間がかかっているのではなく（かかっていることもありますが）、たいていはホスト名ごとの同時接続数に起因するものです。&lt;/p&gt;

&lt;p&gt;ひとつの完全修飾ドメイン名 (FQDN: Fully Qualified Domain Name)に対して、同時接続できる数はたいてい6つまでです。これを超える数のリクエストがくると、7つ目のリクエストは、最初の6つのリクエスト処理がどれかが完了される間、待たなければなりません。この時間も&lt;del&gt;Watitng&lt;/del&gt;待ち時間になります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.browserscope.org/?category=network&amp;amp;v=top-m&amp;amp;ua=Android%202.3%2CAndroid%204%2CiPhone%205&#34;&gt;&lt;img class=&#34;aligncenter size-full wp-image-5138&#34; alt=&#34;connections&#34; src=&#34;/static/blog/2013/08/connections.png&#34; width=&#34;640&#34; height=&#34;225&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このような仕組みのため、一般的に静的ファイルはstatic.t32k.meなどの別ドメインから読み込むことによって、この同時接続数の上限を最大化しようとするのがドメイン・シャーディング（Domain Sharding）という手法です。これにより並列ダウンロードできる数を増やし、リソースのWaitingを可能な限り少なくしています。並列ダウンロード数が増えるからと言って10個の違うドメインから読み込んだとすれば、クライアントの最大コネクション数を大きく超えて意味がなかったり、また最初に説明したDNSルックアップの時間が増えたりして逆に弊害をもたらすようになるので、2,3つあたりのドメインを使うのが無難です。&lt;/p&gt;

&lt;p&gt;全てのHTTPリクエストで以上のようなことが行われているかというと、そうでもありませんが、HTTPリクエストをするということは非常にコストの高い行為だということがお分かり頂けたかと思います。&lt;/p&gt;

&lt;p&gt;ネイティブアプリは初回のアプリダウンロードで、アプリ内にリソースがまとめているので、このようなことは気にしなくてもほぼ良いのですが、Webアプリとなると、いかにサーバーとクライアントのやりとりを減らすか、が問題になってきます。特にRTTに関しては、根本的に改善するにはサーバーをユーザーの近くに置く(Akamaiさんなど)ことしかできないので、フロントエンドの人間にとってはラウンドトリップさせないということが重要になってきます。&lt;/p&gt;

&lt;p&gt;次回からはCSSスプライト、Webフォント、DataURIなど実践的なテクニックを使ってHTTPリクエストの減らし方について学んでいきます。
&lt;table border=&#34;0&#34; cellpadding=&#34;5&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/487311361X/warikiru-22/&#34; target=&#34;_blank&#34;&gt;&lt;img alt=&#34;ハイパフォーマンスWebサイト ―高速サイトを実現する14のルール&#34; src=&#34;http://ecx.images-amazon.com/images/I/51hIDIWHmYL._SL160_.jpg&#34; border=&#34;0&#34; /&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&#34;http://www.amazon.co.jp/%E3%83%8F%E3%82%A4%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9Web%E3%82%B5%E3%82%A4%E3%83%88-%E2%80%95%E9%AB%98%E9%80%9F%E3%82%B5%E3%82%A4%E3%83%88%E3%82%92%E5%AE%9F%E7%8F%BE%E3%81%99%E3%82%8B14%E3%81%AE%E3%83%AB%E3%83%BC%E3%83%AB-Steve-Souders/dp/487311361X%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Dwarikiru-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D487311361X&#34; target=&#34;_blank&#34;&gt;ハイパフォーマンスWebサイト&lt;/a&gt;&lt;br /&gt;
Steve Souders &lt;/span&gt;&lt;/span&gt;オライリージャパン&lt;br /&gt;
2008-04-11&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.amazon.co.jp/%E3%83%8F%E3%82%A4%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9Web%E3%82%B5%E3%82%A4%E3%83%88-%E2%80%95%E9%AB%98%E9%80%9F%E3%82%B5%E3%82%A4%E3%83%88%E3%82%92%E5%AE%9F%E7%8F%BE%E3%81%99%E3%82%8B14%E3%81%AE%E3%83%AB%E3%83%BC%E3%83%AB-Steve-Souders/dp/487311361X%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Dwarikiru-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D487311361X&#34; target=&#34;_blank&#34;&gt;Amazonで詳しく見る&lt;/a&gt;by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34;&gt;G-Tools&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CSS Sprite画像はDataURI画像にすべきか？</title>
      <link>http://localhost:1313/mol/log/sprite-image-vs-inline-image/</link>
      <pubDate>Wed, 31 Jul 2013 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/mol/log/sprite-image-vs-inline-image/</guid>
      <description>&lt;p&gt;最近、スプライト画像はDataURIにすべきですか？という質問が多くて、調べてみました。てか、前のもそんな話題があったような。
&lt;div&gt;DataURIってなんぞって方は下記を見てほしい。&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/data-uri-scheme/&#34;&gt;データURIスキーム | MOL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;blockquote&gt;CSSファイルがパースされなければレンダリングが始まらないのでCSSファイルの肥大化は絶対に避けなければならない。画像の1KBとCSSファイルの1KBを同じように考えてはいけない。
&lt;a href=&#34;http://t32k.me/mol/log/the-perfect-css-i-thought/&#34;&gt;ぼくのかんがえたさいきょうのしーえしゅえしゅ | MOL &lt;/a&gt;&lt;/blockquote&gt;
&lt;a href=&#34;http://molmol.tumblr.com/post/51105314376/dontrblgme-tumblr-lhl6jnlwmc1qzqmk9o1-400-jpg&#34;&gt;憎しみと恐怖にとらわれてはいけない&lt;/a&gt;。あ、ホントそうだっけーなーと思いつつ、どこぞの資料見たんだっけなーと探してたらあった。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;//www.youtube.com/embed/YV1nKLWoARQ&#34; frameborder=&#34;0&#34; width=&#34;560&#34; height=&#34;315&#34;&gt;&lt;/iframe&gt;
&lt;a href=&#34;https://docs.google.com/presentation/d/1IRHyU7_crIiCjl0Gvue0WY3eY_eYvFQvSfwQouW9368/present#slide=id.gc57996a9_0168&#34;&gt;Optimizing the Critical Rendering Path for Instant Mobile Websites - Velocity SC - 2013&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このセッションはすごく分かりやすいのでオススメです（該当の箇所は12分位から）。 というかIlya Grigorik++&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter  wp-image-5056&#34; style=&#34;text-align: center;&#34; title=&#34;1&#34; src=&#34;/static/blog/2013/07/11.png&#34; alt=&#34;&#34; width=&#34;900&#34; /&gt;&lt;/p&gt;

&lt;p&gt;セッション中の資料には、ご覧のとおり、HTMLがパースされてDOMが完成したところで、画面には何も表示されない。感覚的には、スタイルのついてない『Hello world!』くらい表示されてもいいじゃんか！と思うんだけど、表示されない。
&lt;p style=&#34;text-align: center;&#34;&gt;&lt;img class=&#34;aligncenter  wp-image-5055&#34; title=&#34;2&#34; src=&#34;/static/blog/2013/07/21.png&#34; alt=&#34;&#34; width=&#34;900&#34; /&gt;&lt;/p&gt;
次に、CSSがパースされてCSSOM（CSSのDOMみたいなもの？Style Rulesとかとも言ったりする）が構築されるが、まだ画面は空白のままだ。
&lt;p style=&#34;text-align: center;&#34;&gt;&lt;img class=&#34;aligncenter  wp-image-5054&#34; title=&#34;3&#34; src=&#34;/static/blog/2013/07/31.png&#34; alt=&#34;&#34; width=&#34;900&#34; /&gt;&lt;/p&gt;
DOMとCSSOMがガッチャンコしてRender Treeが構築され、そこにレイアウト情報が加わって初めて描画となるんだね。この辺りの更に詳しい情報はHTML5 Rocksの以下の記事がすばらしいので読んでほしい（すぐ眠たくなるけど）。
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://www.html5rocks.com/ja/tutorials/internals/howbrowserswork/&#34;&gt;ブラウザのしくみ: 最新ウェブブラウザの内部構造 - HTML5 Rocks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
ここで重要なのはHTMLと（読み込んでいる）スタイルシート（CSS）が無い限り、描画はされないということだ。つまり、CSSの読み込みに手間取ればCSSレンダリングをブロックするということが考えられる。&lt;/p&gt;

&lt;p&gt;レンダリングをブロックするのはJSファイルだけかと思ってたけど、スタイルシート（CSS）も気をつけなければならないということが分かる。&lt;/p&gt;

&lt;p&gt;そこで冒頭にも述べたように、CSSファイルを出来る限り軽くし、読み込みを速くすることでレンダリングのブロックを回避するという考えになってくると思うが、実際どんなもんなのよ？と思ったので、テストファイル作ってみた。
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;https://dl.dropboxusercontent.com/u/356242/exp/httprequests/normal_sprite.html&#34;&gt;Normal CSS Sprites&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;https://dl.dropboxusercontent.com/u/356242/exp/httprequests/inline_sprite.html&#34;&gt;Inline image CSS Sprites&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
30個くらいのアイコン画像をスプライト化して読み込んでいるのと、それをさらにDataURIにしているもの比較だ。それらを&lt;a href=&#34;http://www.webpagetest.org/&#34;&gt;WebPagetest&lt;/a&gt;にかけてみた。
&lt;p style=&#34;text-align: center;&#34;&gt;&lt;a href=&#34;/static/blog/2013/07/filmstrip.png&#34;&gt;&lt;img class=&#34;aligncenter  wp-image-5040&#34; title=&#34;filmstrip&#34; src=&#34;/static/blog/2013/07/filmstrip.png&#34; alt=&#34;&#34; width=&#34;900&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;strong&gt;ビジュアル比較テスト結果&lt;/strong&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://www.webpagetest.org/video/compare.php?tests=130730_2V_G48,130730_7X_G49&#34;&gt;WebPagetest - Visual Comparison&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;strong&gt;各テスト結果&lt;/strong&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://www.webpagetest.org/result/130730_2V_G48/1/details/&#34;&gt;WebPagetest Test Details - Dulles : Normal&amp;hellip;/normal_sprite.html&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://www.webpagetest.org/result/130730_7X_G49/3/details/&#34;&gt;WebPagetest Test Details - Dulles : DataURI&amp;hellip;inline_sprite.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
どうでしょうか？&lt;/p&gt;

&lt;p&gt;Fully Loadedがノーマルで&lt;strong&gt;1.187s&lt;/strong&gt;で、DataURIが&lt;strong&gt;0.994s&lt;/strong&gt;で、ビジュアル比較においても、表示完了までの時間がDataURIを使用した方が速い。まぁHTTPリクエストが2つと3つじゃ、リクエストの少ないほうが速いのは当たり前なんですけど、ここではレンダリング過程を見てほしい。&lt;/p&gt;

&lt;p&gt;ノーマルは0.7秒あたりから画像なしだけどレンダリングが始まっているのに対して、その時点ではDataURIは真っ白な画面のままだ。&lt;a href=&#34;https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/quick-start-quide#TOC-Start-Render:&#34;&gt;Start Render&lt;/a&gt;を見ても、ノーマルが、&lt;strong&gt;0.697s&lt;/strong&gt;に対して、DataURIは&lt;strong&gt;0.920s&lt;/strong&gt;で、普通の画像のほうがレンダリングが速く始まっている。&lt;/p&gt;

&lt;p&gt;これは先程の、Ilya Grigorik氏のプレゼン内容を理解していれば当然の現象と理解できるだろう。DataURI化した文字列を含んだCSSは&lt;strong&gt;59KB&lt;/strong&gt;サイズもあるのに対して、画像パスで読み込んだCSSは&lt;strong&gt;3KB&lt;/strong&gt;と軽量だ。この読み込みの差が反映された結果になっている。&lt;/p&gt;

&lt;p&gt;比較のテストはシンプルな実装だが、現実問題のサイトはもっと複雑だ。どのようなレンダリング過程になるのかはサイトそれぞれだし、DataURIにして読み込み時間を最小限するというのもひとつの手段かと思う。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index#TOC-Measuring-Visual-Progress&#34;&gt;&lt;img class=&#34;aligncenter size-full wp-image-5075&#34; title=&#34;Visual Progress&#34; src=&#34;/static/blog/2013/07/vp.png&#34; alt=&#34;&#34; width=&#34;900&#34; height=&#34;520&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ただ、我々は機械ではないので、数値を機械的に判断するのではなく、&lt;strong&gt;体感速度&lt;/strong&gt;という観点からも考えなければならない。ノーマルのテストのようなブログレッシブレンダリングは、ユーザーに即座のフィードバックを返している点で、ユーザーに安心感を与えている。&lt;/p&gt;

&lt;p&gt;このような事例として、&lt;a href=&#34;http://t32k.me/mol/log/long-life-web-performance-optimization/&#34;&gt;検索サイトのBingはプログレッシブレンダリングをすることでユーザーの満足度を0.7％向上させた&lt;/a&gt;(サイトリニューアル並に上昇したようです)という例もある。&lt;/p&gt;

&lt;p&gt;であるので、CSSにレイアウト情報をしっかり記述したり、画像が読み込まれていない時点でのスタイルのケア（background-imageだけでなく似たような色のbackground-colorも指定しておくなど）もしておけば、後は画像が当て込まれていくだけなので体感速度は向上するといったことも考えられるだろう。&lt;/p&gt;

&lt;p&gt;セッションでは、AFT(Above-the-fold time)、つまりファーストビューで見える範囲だけのCSSをHTMLにインラインで記述し、残りCSSファイルは遅延読み込みするといったテクニックが披露されているが、実際の運用ベースで使うとなると厳しいだろう。&lt;/p&gt;

&lt;p&gt;そもそも的な話で、
&lt;blockquote&gt;
&lt;ul&gt;
    &lt;li&gt;Base64 encoding incurs transfer size overhead of 1.37 times the original data, with another 814 bytes of header data. Server gzip compression reduces this overhead to around 3% so the penalty is relatively small.&lt;/li&gt;
    &lt;li&gt;The content must be decoded back into it’s original form by the browser. This operation consumes CPU &amp;amp; battery on mobile devices.&lt;/li&gt;
    &lt;li&gt;If data URIs are included in HTML or uncached CSS, the content of the data URI will be sent to the browser from the HTTP server with each request.&lt;/li&gt;
    &lt;li&gt;Regardless of whether the data URI content exists in a cached CSS or HTML file, the browser must decode the image each time a page renders: the decoding cost is paid repeatedly every time a page is viewed.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;a href=&#34;http://www.mobify.com/blog/data-uris-are-slow-on-mobile/&#34;&gt;DataURIの画像は、通常の画像に比べて6倍遅いとかゆう記事&lt;/a&gt;もありますし、ファイルサイズ自体も元より増加するし、毎回デコードしなければならなかったり、
&lt;blockquote&gt;Inline images judiciously
&lt;ul&gt;
    &lt;li&gt;Inlining increases parse time&lt;/li&gt;
    &lt;li&gt;External images don&amp;rsquo;t block the parser&lt;/li&gt;
    &lt;li&gt;Can defer resource discovery and execution&lt;/li&gt;
    &lt;li&gt;SPDY server push &amp;gt; image inlining&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
また、Velocity2012での&lt;a href=&#34;https://perf-metrics-velocity2012.appspot.com/#41&#34;&gt;Understanding and Optimizing Web Performance Metrics&lt;/a&gt;でも、DataURIは慎重に使用しろと言われてますので、用法用量お守りの上、お使いくださいませ。&lt;/p&gt;

&lt;p&gt;個人的な意見としては一回ぐらいしか出てこない画像をDataURIするのであれば、そこのビューに埋め込めばいいし、かと言って何回も出てくるような画像であれば、毎回のデコードコストが気にかかるし、ならスプライトでまとめてキャッシュさせたほうが無難でしょ！と思う。またスプライト画像も今回述べたようにレンダリングのブロックにつながる可能性があるので絶対CSSファイルには入れない、使わない。なんで、使わないかなー。使わないなー、うん。&lt;/p&gt;

&lt;p&gt;参考
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery&#34;&gt;Optimize CSS Delivery - PageSpeed Insights — Google Developers&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;https://developers.google.com/speed/docs/insights/PrioritizeVisibleContent&#34;&gt;Reduce the size of the above-the-fold content - PageSpeed Insights — Google Developers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>パフォーマンスからみるSass/Compass 第1回：Nestingと@import</title>
      <link>http://localhost:1313/mol/log/sass-nesting-and-import/</link>
      <pubDate>Thu, 12 Jul 2012 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/mol/log/sass-nesting-and-import/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://sass-lang.com/&#34;&gt;Sass&lt;/a&gt;とかいろんな機能ありますよね、でもぶっちゃけそんなにいっぱい機能あっても使わないし( ･´ω･｀)　案外、//ダブスラでコメントアウトできるのが一番嬉しかったりもします今日このごろです。&lt;/p&gt;

&lt;p&gt;&lt;h2&gt;@import&lt;/h2&gt;
というわけで、そんな僕がSassを使うと思ったのも@importを使いたかったからという至極単純な動機によるものです。@import自体は普通のCSSでも使えますが、パフォーマンス的に難がありまして、あんまり使う気になれない、かといってファイル管理はページ単位やコンポーネント単位でちゃんとやらないと後々めんどいなというジレンマもあります。&lt;/p&gt;

&lt;p&gt;そうゆうわけで、なんで普通の@importがダメなのか説明します。
&lt;blockquote&gt;IEにおいて@importはページ下部に置いた&amp;lt;link&amp;gt;タグのような挙動をします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://developer.yahoo.com/performance/rules.html/rules.html#csslink&#34;&gt;Best Practices for Speeding Up Your Web Site &lt;/a&gt;&lt;/blockquote&gt;
Yahoo!のパフォーマンスベスト・プラクティスにおいて、上記のような記述がありました。Styleの情報というのはできる限りページ上部に置いてレンダリングを早く開始させる必要があるのでこれは頂けませぬ。&lt;/p&gt;

&lt;p&gt;まぁ基本的に@importのパフォーマンス的問題はIE以外ならOKであれば使ってもいいのかなと思ってたんですけど、よくよく調べてみるとそうでもなかったですという話。
&lt;pre&gt;&lt;code&gt;/* first.css */
@import url(&amp;ldquo;second.css&amp;rdquo;)&lt;/code&gt;&lt;/pre&gt;
まぁ上記のような&amp;lt;link&amp;gt;で読み込んだfirst.cssでsecond.cssを@importするといった例があるとします。これがどのような挙動をするのかと言いますと、
&lt;blockquote&gt;ブラウザーはsecond.cssをダウンロード可能と発見する前に、必ずfirst.cssのダウンロード、パース、実行をする。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developers.google.com/speed/docs/best-practices/rtt#AvoidCssImport&#34;&gt;Minimize round-trip times - Make the Web Faster — Google Developers&lt;/a&gt;&lt;/blockquote&gt;
Googleの方には上記のようなことが書かれていました。つまり、first.cssを読み込み完了してからsecond.cssを読み込みに行くので並列ダウンロードができないってことです。これってIEに限ったことではなくてすべてのブラウザーで起こりうることらしいです。マジかいや！てことで、&lt;a href=&#34;http://stevesouders.com/tests/atimport/link-with-import.php&#34;&gt;Steve Soudersセンセのテストケース&lt;/a&gt;を最新のChromeのNetworkパネルで見てみると本当にそうでした。さーせん！ということで、やっぱり普通の@importは使うべきではないですな。&lt;/p&gt;

&lt;p&gt;詳しくは下記ブログ読むと良いよ。
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://www.stevesouders.com/blog/2009/04/09/dont-use-import/&#34;&gt;don’t use @import | High Performance Web Sites &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
まぁ、そうゆうわけでSassの@importですよ。基本ローカル環境でコンパイルして一つのCSSファイルにまとめるので、読み込むのは実質1ファイルだけになるんですね。それでいて、ページ単位やコンポーネント単位でファイル分割できるのでコードの見通しも悪くならない、素敵です。sass &amp;ndash;watchとか&lt;a href=&#34;http://mhs.github.com/scout-app/&#34;&gt;Scout&lt;/a&gt;とか使えば毎回手動でコンパイルしなくても更新があれば自動的にコンパイルしてくれます。
&lt;pre&gt;&lt;code&gt;// Sass
 @import &amp;ldquo;_reset&amp;rdquo;;
 @import &amp;ldquo;_common&amp;rdquo;;
 @import &amp;ldquo;_header&amp;rdquo;;
 @import &amp;ldquo;_main&amp;rdquo;;
 @import &amp;ldquo;_footer&amp;rdquo;;&lt;/code&gt;&lt;/pre&gt;
これだけのためにでもSass導入してもいいんじゃないかと個人的には思っています。
&lt;h2&gt;Nesting&lt;/h2&gt;
あと、便利っちゃー便利なのがネストです。下記のようにセレクタ、プロパティの重複する部分ってのを省略して書けます。
&lt;pre&gt;&lt;code&gt;// Sass
table.hl {
  margin: 2em 0;
  td.ln {
    text-align: right;
  }
}
li {
  font: {
    family: serif;
    weight: bold;
    size: 1.2em;
  }
}&lt;/code&gt;&lt;/pre&gt;
上記は下記のようにコンパイルされます。
&lt;pre&gt;&lt;code&gt;/* CSS */
table.hl {
  margin: 2em 0;
}
table.hl td.ln {
  text-align: right;
}
li {
  font-family: serif;
  font-weight: bold;
  font-size: 1.2em;
}&lt;/code&gt;&lt;/pre&gt;
子孫セレクタとか何回も同じセレクタを宣言するのはめんどいですよね。あとモジュール単位で、例えば.module{}以下に必要なスタイルをネストしておけば、そのモジュールが要らなくなったりとか修正が必要になった時とか対応が楽です。&lt;/p&gt;

&lt;p&gt;とは言いつつも、そのモジュールの見通しが甘くて案外複雑なことをやらないとだめになりネストが3階層、4階層となってしまう時があります。そうなるとコンパイルされたCSSというのは子孫セレクタとかでつながった長いセレクタになってしまいます。&lt;/p&gt;

&lt;p&gt;これってどーなのよ？って話ですよね。はじめに言っておきますが気にしなくてもいい。&lt;/p&gt;

&lt;p&gt;世の中には&lt;a href=&#34;https://developer.mozilla.org/ja/Writing_Efficient_CSS&#34;&gt;CSSセレクタの最適化&lt;/a&gt;というものがありまして、要はCSSセレクタの解釈というのは&lt;strong&gt;右から左へ&lt;/strong&gt;とされていくわけでして、セレクタが長ければ長いほど解釈するのに時間がかかるので、単一のクラスセレクタとかにしたらいいよーみたいな話です。&lt;/p&gt;

&lt;p&gt;これってどんだけの程度なのよ！？ってことが気になります。詳しくは下記翻訳でまとめられています。
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/impact-of-css-selector/&#34;&gt;CSSセレクタのパフォーマンスへの影響 | MOL &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
1000個のCSSセレクタを改善しても20msくらいしか変わらなかったという結論です。これは2009年の話でして、世の中進歩しています。
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://calendar.perfplanet.com/2011/css-selector-performance-has-changed-for-the-better/&#34;&gt;Performance Calendar » CSS Selector Performance has changed! (For the better) &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
2011年の年末に書かれた上記の記事ではwebkitに関してですが、CSSセレクタのマッチング処理ってのはブラウザ側で最適化されているという話です。
&lt;ol&gt;
    &lt;li&gt;Style Sharing&lt;/li&gt;
    &lt;li&gt;Rule Hashes&lt;/li&gt;
    &lt;li&gt;Ancestor Filters&lt;/li&gt;
    &lt;li&gt;Fast Path&lt;/li&gt;
&lt;/ol&gt;
上記のような改善がされていてるとのことでして、詳しいことは日本語で解説されてる以下のブログで（素敵！）
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34; http://memolog.org/2012/05/css_selector_performance.php  &#34;&gt;CSS Selector Performance - メモログ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
まぁ要するに2009年段階でも気にしなくてもいいレベルだったのにそれから2年経ってさらに気にしなくてもいいレベルになってきた感じです。
&lt;pre&gt;&lt;code&gt;/* Baseline
　コード量の差をなくすためにマッチングしないセレクタが記述されている*/
.noclass0001 { background: #CFD; }&lt;/p&gt;

&lt;p&gt;/* Descendant*/
DIV DIV DIV P A.class0001 { background: #CFD; }&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://stevesouders.com/tests/css-selectors/baseline.php&#34;&gt;CSS Selectors: Baseline &lt;/a&gt;（ベースライン）&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://stevesouders.com/tests/css-selectors/descendant.php&#34;&gt;CSS Selectors: Descendant &lt;/a&gt;（子孫セレクタ）&lt;/li&gt;
&lt;/ul&gt;
試しに、最新のChromeで上記のSoudersセンセのテストケースをもう一度やってみると、数ミリ秒しか変わんなかったです。1000個のセレクタ改善しても数ミリ秒しか違わないのは費用対効果悪すぎです。&lt;/p&gt;

&lt;p&gt;ってことで、Sassでネストしまくって、それによるセレクタの解釈遅延ってのは気にしなくてもいいのかなという個人的結論。もちろん、ネストしまくったら何がなんだかわからないCSSになってしまうので、可読性のために、2,3階層程度でとどめておくほうが良いでしょう。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Long Life Web Performance Optimization ~ 心理学から考えるWebパフォーマンス ~</title>
      <link>http://localhost:1313/mol/log/long-life-web-performance-optimization/</link>
      <pubDate>Wed, 24 Nov 2010 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/mol/log/long-life-web-performance-optimization/</guid>
      <description>&lt;p&gt;クライアントサイド・パフォーマンス・ロード・オブ・ザ・リング3部作ついに完結ですw。ということで、&lt;a href=&#34;http://dotcoder.net/2010/10/09/1219&#34;&gt;dotcoder&lt;/a&gt;や&lt;a href=&#34;http://www.wcaf.jp/archives/2010/10/29/144/&#34;&gt;WCAF&lt;/a&gt;で話しました Long Life Web Performance Optimization について薄れゆく記憶の復習も兼ねて思いの丈を綴ってみた。&lt;/p&gt;

&lt;p&gt;過去の作品
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/high-performance-web-design/&#34;&gt;High Performance Web Design ~デザインから考えるハイパフォーマンスWebサイト~&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://t32k.me/mol/log/coding-web-performance/&#34;&gt;Coding Web Performance ~Webパフォーマンス最適化のためのコーディング手法~ &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&#34;__ss_5860661&#34; style=&#34;width: 425px;&#34;&gt;&lt;strong&gt;&lt;a title=&#34;Long Life Web Performance Optimization&#34; href=&#34;http://www.slideshare.net/t32k/long-life-web-performance-optimization&#34;&gt;Long Life Web Performance Optimization&lt;/a&gt;&lt;/strong&gt;&lt;object id=&#34;__sse5860661&#34; classid=&#34;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&#34; width=&#34;425&#34; height=&#34;355&#34; codebase=&#34;http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0&#34;&gt;&lt;param name=&#34;allowFullScreen&#34; value=&#34;true&#34; /&gt;&lt;param name=&#34;allowScriptAccess&#34; value=&#34;always&#34; /&gt;&lt;param name=&#34;src&#34; value=&#34;http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=longlifewebperformanceoptimization-101122074016-phpapp02&amp;amp;stripped_title=long-life-web-performance-optimization&amp;amp;userName=t32k&#34; /&gt;&lt;param name=&#34;name&#34; value=&#34;__sse5860661&#34; /&gt;&lt;param name=&#34;allowfullscreen&#34; value=&#34;true&#34; /&gt;&lt;embed id=&#34;__sse5860661&#34; type=&#34;application/x-shockwave-flash&#34; width=&#34;425&#34; height=&#34;355&#34; src=&#34;http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=longlifewebperformanceoptimization-101122074016-phpapp02&amp;amp;stripped_title=long-life-web-performance-optimization&amp;amp;userName=t32k&#34; name=&#34;__sse5860661&#34; allowscriptaccess=&#34;always&#34; allowfullscreen=&#34;true&#34;&gt;&lt;/embed&gt;&lt;/object&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;
タイトルのLong Life Web Performance Optimization、長いのでLong Life WPOって略します。これは、Long Life Designからもじりました。Long Life Design というのは&lt;a href=&#34;http://www.d-department.com/jp/&#34;&gt;D&amp;amp;DEPARTMENT PROJECT&lt;/a&gt;のナガオカケンメイさんが行っているプロジェクトで、60年代とか70年代の昔の優れたデザインを今にも伝えて使い続けていこうって趣旨だったと思います。それに対して、Webの世界はどうでしょう？移り変わりが早いですよね。「お！これが90年代のテーブルレイアウトかぁ〜エクセレント！」なんてことはない。そこで今回はLong Life Designのように長〜く使えるWPOを心理学などの人間側から考えてみようってのが今回のセッションの狙いです。&lt;/p&gt;

&lt;p&gt;&lt;h3&gt;Agenda&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#news&#34;&gt;最近のパフォーマンス事情 | News&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#machine&#34;&gt;機械は変わる | Machine&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#human&#34;&gt;人間は変わらない | Human&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#practice&#34;&gt;プラクティス | Practice&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;まとめ | Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;news&#34;&gt;Web Performanceは死んだか？&lt;/h3&gt;
&lt;img class=&#34;fig&#34; title=&#34;wpo.003&#34; src=&#34;/static/blog/2010/11/wpo.003.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ちょっと釣りっぽい見出しですが、最近パフォーマンスの話、聞かないですよね？去年の暮れあたりが賑わい的にピークだったかと思います。(※Googleのランキングアルゴリズ追加に関しても情報全くないですし&amp;hellip;)とはいえ、結構パフォーマンス事情は賑やかですってのをこれから紹介していきます。
&lt;h4&gt;Web Performance Working Group&lt;/h4&gt;
もっともビッグなニュースと言えば、W3Cで8/19にWeb Performance Working Groupが設立されたことです。このWorking GroupのミッションはWebアプリケーションのパフォーマンス計測のための仕様を作ることです。共同議長にはMicrosoftとGoogleの方がいます。この辺からMSのWebパフォーマンスに対する本気度が伺えますよね。今後に期待です。
&lt;h4&gt;API for Measuring Web Performance&lt;/h4&gt;
そこで策定されていくのが計測のためのAPIです。で、そのAPIとはなんぞや？ってことなんですけども、
&lt;ul&gt;
    &lt;li&gt;Navigation Timing
ネットワークや読み込みなどの時間、リクエスト回数などの情報を取得することができます。&lt;/li&gt;
    &lt;li&gt;Resource Timing
画像やスクリプトなどのリソースを読み込むときの時間、情報を取得することができます。&lt;/li&gt;
    &lt;li&gt;User Timing
UAがコードを実行した時間を取得することができます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;text-align: right;&#34;&gt;&lt;span style=&#34;font-size: x-small;&#34;&gt;&lt;a href=&#34;http://standards.mitsue.co.jp/archives/001473.html&#34;&gt;2010年8月のW3C | Web標準Blog | ミツエーリンクス&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
window.performance.navigation.loadEnd みたいな感じでページの読み込み時間が簡単に分かるようになるんですね。つまり、YSlow や PageSpeed などのプラグインなしでも詳細な情報が取得することができます。このAPIを実装しているブラウザは共同議長の選出先と同じようにIE9とChrome6からとなっています。
&lt;h4&gt;Boomerang.js&lt;/h4&gt;
それじゃ利用するにはまだまだ先の話だと思うのですが、そうでもないんですね。次に紹介するのはオープンソースのパフォーマンス計測ライブラリの&lt;a href=&#34;http://yahoo.github.com/boomerang/doc/ja/&#34;&gt;Boomerang.js &lt;/a&gt;です。開発者は Yahoo! Inc. の Philip Tellis さんです。この Boomerang.js 先に紹介したパフォーマンス計測APIに似た機能を提供してくれます。（はてブコメントより、ブラウザがそのAPIをサポートしていればそれを利用するみたいですね。ありがとうございます。参考：&lt;a href=&#34;http://developer.yahoo.com/blogs/ydn/posts/2010/07/boomerang_webtiming_api/&#34;&gt;Boomerang and the WebTiming API · YDN Blog&lt;/a&gt; ）&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;fig&#34; title=&#34;wpo.006&#34; src=&#34;/static/blog/2010/11/wpo.006.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;普通、自前でページのパフォーマンス計測しようと思うと、HEAD要素あたりに、new DateしてgetTimeで現在時刻を取ってきて、BODYの最後のほうでまたgetTimeして、その差分の時間を計測するといったことをするかと思います。これですと、最初のnew Dateから次のnew Dateするまでの時間、つまりドキュメント内での時間しか計測できてないわけですね。もっと重要なサーバーとのやりとりの時間、ネットワークのレイテンシなども考慮されていないわけです。これじゃいかんやろうと言うことで、このBoomerang.js を使うとどうなるかと言うと、BODY要素の最後らへんでBoomerang.jsを読み込み、初期化関数を書くだけで、ネットワークのレイテンシなどの時間を計測することが可能です。また取得した情報を任意のサーバーに送れることも可能です。&lt;/p&gt;

&lt;p&gt;これをうまく利用できたら、Google Analytics と連携してパフォーマンスの良いユーザーがどれだけコンバージョンがあげたかなど詳細に記録できるかと思います。楽しみですね。
&lt;h4&gt;Beyond Design&lt;/h4&gt;
最後に話題を変えて、今年5月に開かれたGoogle I/O 。&lt;a href=&#34;http://www.google.com/intl/ja/events/io/2010/sessions/beyond-design-user-experience.html&#34;&gt;GoogleとYouTubeの人が話したセッション&lt;/a&gt;より良いユーザーエクスペリエンスの作り方の原則として、第1に速くあれ！ってことを挙げていました。もともと、Googleのデザインガイドラインでも速さってのは重要だと言ってきているので、これ自体は特に珍しいことではないのですが、そこで引用されていた言葉が興味深かったので挙げてみました。
&lt;blockquote&gt;“Speed is the most important feature. If your application is slow, people won’t use it. I see this more with mainstream users than I do with power users. I think that power users sometimes have a bit of sympathetic eye to the challenges of building really fast web apps, and maybe they’re willing to live with it, but when I look at my wife and kids, they’re my mainstream view of the world. If something is slow, they’re just gone.”
&lt;p style=&#34;text-align: right;&#34;&gt;&lt;span style=&#34;font-size: x-small;&#34;&gt;— Fred Wilson (Union Square Ventures)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
フレッド・ウィルソンさんはTwitterにも投資している有名なベンチャー投資家ですね。この人が言った言葉に「スピードはもっとも重要な特徴だ、もしアプリケーションが遅ければ誰も使わなくなるだろう。この傾向はパワーユーザーよりもメインストリームのユーザーで顕著だ」と。パワーユーザーというのは日本で言えば、はてなを使っているような人たちでしょう。彼らはそれなりの知識があるので、ページが遅くても同情的な感情になるらしいです。負荷分散大変だろうなとか。大して、メインストリームユーザー、つまりノンデベロッパーの人はそんなこと知りませんから、なんで遅いん？は？みたいな感じですぐ去ってしまうんですね。&lt;/p&gt;

&lt;p&gt;ここで重要なのは、スピードというのは決して一部のパフォーマンスオタクのだけのもではないということです。フレッドさん自体、投資家であり開発者ではありませんので、&lt;strong&gt;スピード&lt;/strong&gt;というのは全ての人が当然のように期待するモノなのかなと考えます。&lt;/p&gt;

&lt;p&gt;これまで見てきたように言わずもがなWPOというのは私たちにとって常に最重要課題なのではないかと考えます。さらに、前述のパフォーマンス計測の標準化が進めば、皆が同じルールの環境下で比較されるので、パフォーマンスが良いということはセールスポイントになることはもちろん、今後はミリ秒単位での厳しい争いになったりするのかなと考えます。
&lt;h3 id=&#34;machine&#34;&gt;機械は進化する&lt;/h3&gt;
&lt;img class=&#34;fig&#34; title=&#34;wpo.011&#34; src=&#34;/static/blog/2010/11/wpo.011.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Webパフォーマンスというのは重要なのは理解できたかと思うので、今度はそれを対策するために機械（コンピュータ）の部分に目を向けてみましょう。
&lt;h4&gt;ムーアの法則&lt;/h4&gt;
機械というのは当然のことながらものすごく進化が速いです。有名な&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E3%83%A0%E3%83%BC%E3%82%A2%E3%81%AE%E6%B3%95%E5%89%87&#34;&gt;ムーアの法則&lt;/a&gt;で半導体の集積密度は18〜24ヶ月で倍増するというのがあります。まぁ簡単に言ったら、半導体の性能はものすごいスピード向上していくことになります。２年前の自分と比べて今の自分が２倍成長してるかと言うと、そうではないですよね？人間と比べれば進化のスピードというのは比較にならないほど速いものです。&lt;/p&gt;

&lt;p&gt;Webの世界においても同じことが言えます。現在、WPO でもっとも有効な対策であるHTTPリクエストを減らすこと。これまで２度クライアントサイドでのパフォーマンスについて話してきましたが、言っていることはただ一つです。HTTPリクエストを減らすことしか僕は言っていません。現状はリクエストを減らすには、イメージマップ、CSSスプライト、インライン画像、ファイルの結合といったことが挙げられます。では、こういった対策がブラウザ（機械）の改善（進化）が進めばどのように変わるのか次は見ていきましょう
&lt;h4&gt;CSS3&lt;/h4&gt;
&lt;img class=&#34;fig&#34; title=&#34;wpo.014&#34; src=&#34;/static/blog/2010/11/wpo.014.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;まずはCSS3。画像はコニッターさんの&lt;a href=&#34;http://re-dzine.net/apple/iphone/2010/06/17/css3-iphone4/&#34;&gt;iPhone4をCSS3で描いてみた&lt;/a&gt;です！このような込み入ったものもCSS3で描けるということは、言わずもがなグラデーションボタンや見出しの背景画像といった比較的簡単なものならCSS３で十分事足りる可能性は大きいわけです。&lt;/p&gt;

&lt;p&gt;ちなみに&lt;a href=&#34;http://code.google.com/intl/ja/speed/articles/web-metrics.html&#34;&gt;Googleが42億ページ調べた結果&lt;/a&gt;、１ページにあるリソースの和は平均44個でそのうち画像の平均は29個と最も多く全体の60-70％に当たるらしいです。このようなデータからも画像を減らすことはHTTPリクエストを減らす有効な対策だと考えます。
&lt;h4&gt;Application Cache&lt;/h4&gt;
アプリケーションキャッシュは、HTML5のオフライン機能ですね。マニフェストファイルというテキストファイルにキャッシュさせたいファイル名（パス）を記述しHTMLのマニフェスト属性に指定するだけで、セッションを越えての、オフラインでのキャッシュが可能になります。&lt;/p&gt;

&lt;p&gt;つまり、１回リクエストしてキャッシュしてしまえば、次回以降は余計なリクエストは発生させないということです。この機能と同じことを実現しようと思うと、サーバーの方でEXPIREヘッダに遠い未来を指定しなければならないんですけど、アプリケーションキャッシュの場合クライアント側ですべてできるのは使い勝手がよいですね。
&lt;h4&gt;Resource Package&lt;/h4&gt;
次に、リソースパッケージなんですがこれは&lt;a href=&#34;http://hacks.mozilla.org/2009/11/a-proposal-resource-packages-to-improve-performance/&#34;&gt;Mozillaの中の人提案した機能&lt;/a&gt;で、簡潔にゆうとZIPでくれ！ってことです。何回もリクエストするから効率が悪いので全部ZIPでまとめて、そのZIPファイルだけリクエストするというやり方です。いやーこれ考えた頭いいですね。てかなんで今までなかったのか分からないほどクレバーな技術なんですけど、Firefox3.7に実装されるかどうかって話しだったんですけど、全然話にきかないので、たぶんFirefox5とかになるのでしょうか。&lt;/p&gt;

&lt;p&gt;実装方法はZIPで配信したいファイル + マニフェストテキストにリソースのパスを書いてlink要素でリクエストするといった感じですね。考え方としてはCSS Sprite（1つの画像に複数の役割を持たせる）に近いのですが、Background Positionをちまちま設定しなくてもいい分、リソースパッケージのほうが圧倒的に管理が楽です。
&lt;h4&gt;SPDY&lt;/h4&gt;
最後は、&lt;a href=&#34;http://www.chromium.org/spdy&#34;&gt;Googleが提案したSPDY&lt;/a&gt;というプロトコルです。こちらはブラウザの機能改善というより現状のHTTP通信変えようぜってことです。だからといって、&lt;a href=&#34;http://example.com&#34;&gt;http://example.com&lt;/a&gt; のところが spdy://example.com となるということではありません。もっと裏側の部分が変わるんですね。SPDY で実現できるのはこの３つです。
&lt;ul&gt;
    &lt;li&gt;多重化ストリーム&lt;/li&gt;
    &lt;li&gt;リクエストの優先付け&lt;/li&gt;
    &lt;li&gt;HTTPヘッダーの圧縮&lt;/li&gt;
&lt;/ul&gt;
一番重要なのは多重化ストリームです。これは現状のHTTP通信だと、1のホスト名に同時に2つのリクエストしかできません。2コネクション貼られて2リクエストするわけですから、つまり1コネクション1リクエストの原則です。これを解消するために、最新のブラウザは6つまでコネクションを貼ることができるのですが、これが1000ユーザー、10000ユーザーが同時接続してきたらどうでしょう？6万コネクションがサーバーに貼られるわけですからあまり効率のよいことではないですよね。。そこで、SPDYでは1コネクションにリクエストする制限撤廃しました。1つのコネクションを何度も再利用するんですね。これが多重化ストリームです。なぜ、HTTPリクエストがコストが高いのかというと、リクエストするたびに接続・解除を繰り返すから効率が悪いので、SPDYはこの点を解決できるのではないでしょうか。&lt;/p&gt;

&lt;p&gt;これまで4つ見てきたように、現在最も注意しなければならないHTTPリクエストも、近い将来、ブラウザの機能改善やネットワークの仕組みが変われば特に意識する必要はなくなるかもしれません。&lt;/p&gt;

&lt;p&gt;とはいえ、実際問題、各ブラウザが一斉に改善（アップデート）されるわけではありませんので、各ブラウザの実装度を見つつ対応しなければならない状況は続きます。つまり、私たち製作者はは常に走り続けなければなりません(‘･ω･｀）&amp;hellip;
&lt;h3 id=&#34;human&#34;&gt;人間は変わらない&lt;/h3&gt;
&lt;img class=&#34;fig&#34; title=&#34;wpo.020&#34; src=&#34;/static/blog/2010/11/wpo.020.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;そこで、人間側に着目する必要があります。人間というのは昔から何も変わっていません。オギャーって生まれて恋をしてカクカクシカジカで死んでいくわけですよ。少なくとも、2年毎に2倍成長しているかといえばそうではありません。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;fig&#34; title=&#34;wpo.021&#34; src=&#34;/static/blog/2010/11/wpo.021.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;要はこれまでは機械側ばっかりに着目してきたわけですけど、ここは進化が速い、ついて行くのはしんどいってことで、もっと変化の遅い人間側に着目しましょう。そうすればもっと楽できるかもしれませんってのが今回のセッションの狙いでもあります。
&lt;p style=&#34;text-align: center;&#34;&gt;&lt;span style=&#34;font-size: medium;&#34;&gt;&lt;span style=&#34;color: #800080;&#34;&gt;&lt;strong&gt;&lt;span style=&#34;color: #999999;&#34;&gt;認知・知覚・感受・体感&lt;/span&gt; | Perception&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
そこで、人間は知るうえで重要になってくるのが知覚の問題です。理論的に人間は最大で、1秒間126bit、 1分感で7560ビット、1時間50万ビットくらいの大量の情報を処理できるそうです。でも実際は毎秒10ビットくらいしか処理していません。つまり、結構省エネ、 相対的に判断したり、これまでの知識を元に判断したりして情報を簡略して処理しています。 &lt;strong&gt;つまり、世界をありのままにインプットしているわけではありません。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E3%83%81%E3%82%A7%E3%83%83%E3%82%AB%E3%83%BC%E3%82%B7%E3%83%A3%E3%83%89%E3%83%BC%E9%8C%AF%E8%A6%96&#34;&gt;&lt;img class=&#34;fig&#34; src=&#34;/static/blog/2010/11/wp.023-001.png&#34; alt=&#34;チェッカーシャドウ錯視&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;このことを理解するのに良い例があります。上記の図のA、Bのマスの色は違いますよね、実は2つは同じ色なんですね。2本のグレーの線を引きますと、同じ#6B6B6Bのグレーだと理解できます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%93%E3%83%B3%E3%82%B0%E3%83%8F%E3%82%A6%E3%82%B9%E9%8C%AF%E8%A6%96&#34;&gt;&lt;img class=&#34;fig&#34; src=&#34;/static/blog/2010/11/wp.024-001.png&#34; alt=&#34;エビングハウス錯視&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;もう1つ例がありますので紹介します。こちらは2つのオレンジ色の円の大きさは左の円の大きさの方が小さく感じます。しかし、これも周りのオブジェクトを消してみると同じ大きさというのが分かりますよね。&lt;/p&gt;

&lt;p&gt;つまり、人間というのは曖昧に世界を知覚しているのが理解できるかと思います。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;fig&#34; title=&#34;wp.025-001&#34; src=&#34;/static/blog/2010/11/wp.025-001.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これは、別に視覚だけに限ったことではありません。時間感覚においても同じようなこと言えます。&lt;a href=&#34;http://www.newscientist.com/article/mg15220571.700-why-time-flies-in-old-age.html&#34;&gt;アメリカの神経科学学会の人が発表したレポート&lt;/a&gt;によると、同じ3分という時間でも、若い人とお年を召した方では体感時間が違うといったデータが報告されています。この調査によると若い人にとっては3分は自分で秒数をカウントするとで実際は平均3:03秒くらいだったそうです。対して、60歳以上の人にとって3分は3:40秒に感じられたようです。つまり、お年を召した方のほうが流れている時間は速く感じているようです。&lt;/p&gt;

&lt;p&gt;時間感覚は年齢以外にも、地理的条件で違ったり、文化気候、体温によっても影響をうけるようです。もうちょっと具体的にWebではどんな事例があるかと言いますと、&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;fig&#34; title=&#34;wp.027-001&#34; src=&#34;/static/blog/2010/11/wp.027-001.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;User Interface Engineering Blog が&lt;a href=&#34;http://www.uie.com/articles/download_time/&#34;&gt;2001年に調べた調査&lt;/a&gt;があります。ユーザーに10個の違うサイトを使ってもらってどのサイトが一番速く感じたか？という調査です。&lt;/p&gt;

&lt;p&gt;調査結果を見てみると、About.comは実際の平均読み込み時間が8秒で一番速かった（※2001年調べです）にもかかわらず、ユーザーからは一番遅いと判断されました。対して、amazon.comは実際の平均読み込み時間が36秒ともっとも遅かったにもかかわらず、ユーザーからは最も速いと評価されました。&lt;/p&gt;

&lt;p&gt;この調査のまとめでは、実際のダウンロード時間と体感速度に相関性はなく、それよりもユーザーのタスク処理の成功度具合と体感速度に相関性があると締めくくっていました。
&lt;p style=&#34;text-align: center;&#34;&gt;&lt;span style=&#34;color: #888888;&#34;&gt;&lt;span style=&#34;font-size: medium;&#34;&gt;&lt;strong&gt;スピードは重要じゃない!? &lt;span style=&#34;color: #800080;&#34;&gt;| Speed&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
え、これって、スピードって重要じゃないってこと？&lt;/p&gt;

&lt;p&gt;このことを理解するのに重要なキーワードを持つ人物がアメリカの心理学者のミハイチクセントミハイです。彼が提唱した概念にフローというのがあります。&lt;/p&gt;

&lt;p&gt;フローつまり流れるというこの言葉の意味は、
&lt;blockquote&gt;１つの活動に深く没入し他の何ものも問題とならなくなる状態&lt;/p&gt;

&lt;p&gt;注意が自由に個人の目標達成のために投射されている状態&lt;/blockquote&gt;
のことを指します。つまり、完全に集中している状態のことですね。皆さんも経験ありませんか？コーディングがのりに乗って気づいたらお昼だった。またはもう定時？といったことないですかね？ああいった感じを想像してもらえれば理解が速いかと思います。&lt;/p&gt;

&lt;p&gt;フローの構成要素にはこうっいったものが挙げられます。
&lt;ul&gt;
    &lt;li&gt;明確な目的&lt;/li&gt;
    &lt;li&gt;専念と集中&lt;/li&gt;
    &lt;li&gt;活動と意識の融合&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;&lt;span style=&#34;color: #800080;&#34;&gt;時間感覚のゆがみ&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;color: #000000;&#34;&gt;直接的で即座な反応&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;能力の水準と難易度とのバランス&lt;/li&gt;
    &lt;li&gt;自分で制御している感覚&lt;/li&gt;
    &lt;li&gt;活動に本質的な価値がある&lt;/li&gt;
&lt;/ul&gt;
明確な目的をもって集中している状態ですよね。ここで重要なのは時間感覚のゆがみです。つまり、先程のamazon.comの結果をフローを用いて、もう1度説明すると実際速度が遅かったにも関わらず速いと評価されたのはタスクの成功率、使いやすさのおかげで集中することができ、軽いフローみたいな状態にユーザが近づいたため、時間感覚がゆがみ、実際の速度以上に速いと感じるようになったのではと考えられます。&lt;/p&gt;

&lt;p&gt;つまり、このフローをうまく利用することができれば、サイトの体感速度も向上させることができるのではないでしょうか？&lt;/p&gt;

&lt;p&gt;この人間編をまとめますと、人間を曖昧で相対的です。しかし、フローといったモデルをうまく利用することでWPOにもうまく利用できると考えます。
&lt;h3 id=&#34;practice&#34;&gt;実践編&lt;/h3&gt;
&lt;img class=&#34;fig&#34; title=&#34;wp.035-001&#34; src=&#34;/static/blog/2010/11/wp.035-001.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;さて、ここからはWebサイトにフローを落とし込むためにはどうしたら良いのか考えてみましょう。&lt;/p&gt;

&lt;p&gt;ここまで人間側の部分を考えてきました。しかし、体感速度を向上させるために人間の頭をこねくりまわすことはできないので、知覚される前になにか対策する必要性がありますね。つまり、インターフェイスが重要になってくるわけです。&lt;/p&gt;

&lt;p&gt;Webインターフェイスをデザインするパターンはいろいろあるのですが、ここではフローの構成要素から、&lt;strong&gt;直接的で即座な反応&lt;/strong&gt;と、&lt;strong&gt;自分で制御している感覚&lt;/strong&gt;から考えるに、
&lt;p style=&#34;text-align: center;&#34;&gt;&lt;span style=&#34;font-size: medium;&#34;&gt;&lt;span style=&#34;color: #999999;&#34;&gt;&lt;strong&gt;フィードバック&lt;span style=&#34;color: #800080;&#34;&gt; |Feedback&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
フィードバックというパターンがフローを作り出すに最適なパターンかと今回は考えます。では、実際にフローのためにどのようなフィードバックをしたらよいのか見ていきましょう。
&lt;h4&gt;Live Preview&lt;/h4&gt;
まずはライブプレビュー。Twitterのパスワード設定とかナイスだと思うんですね。まぁなんてこたないんですけども、パスワードの安全度をタイプするたびに提示（プレビュー）してくれるんですね。もしこれがライブではなくて、とりあえず入力して、設定ボタン押してページが切り替わってから「パスワードに不備があります。もう一度設定しなおしてください。」言われたらどうでしょう。さらに一度入力したフォームの情報もクリアになってたらどうでしょうか？完全にフローは断ち切られますよね。ライブプレビューはそういった意味で、即座の反応と自分で操作している感からフローを作るのに最適化と考えます。
&lt;h4&gt;Progressive Rendering&lt;/h4&gt;
次のフィードバックはもう少し短いスパンにおいてのフィードバックです。プログレッシブレンダリングとは、まぁプログレッシブエンハンスメントという言葉もあるように、漸次的、段階的レンダリングと考えればよいでしょう。つまり、真っ白なページから、いきなりページが表示されるのではなく、ヘッダー、サイドナビ、メインコンテンツといった具合に順々にレンダリングしていく具合です。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;fig&#34; title=&#34;wp.041-001&#34; src=&#34;/static/blog/2010/11/wp.041-001.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;プログレッシブレンダリングで有名な&lt;a href=&#34;http://radar.oreilly.com/2009/06/bing-and-google-agree-slow-pag.html&#34;&gt;Bingの事例&lt;/a&gt;のよると、Bingの検索結果画面はそれまでプログレッシブレンダリングしてませんでした。検索クエリを入力して結果が表示されるまでに真っ白な画面をユーザーに表示させていました。そこで、スライドの紫色の選より上の部分、ビジュアルヘッダーの部分是が非でもまず表示させるように対応したようです。そうしただけで、各種評価は軒並み上昇しました。中でも、ユーザーの満足度は0.7％上昇と、ページをリニューアルしたとき並の効果があったようです。&lt;/p&gt;

&lt;p&gt;ここで重要なのは全体のページの読み込み速度自体は変わってはいないのですが、まず何か見せておくことでユーザーに安心感を与えるいるわけですね。
&lt;h4&gt;Progress Indication&lt;/h4&gt;
最後はお馴染みのインジケータですね。ページの読み込み速度が速いことにこしたことはないのですが、やはり、どうしても読み込みに時間がかかる場合もあるわけですよね、FLASHサイトとか。そういった場合に、ユーザーをつなぎとめとくために、フィードバックを返しつづけることで安心感を与えることは大切です。それは、読み込み中&amp;hellip; ていった文言でもいいですし、くるくるとか、 プログレスバーなどのケアを心がけたいところです。
&lt;h4&gt;&lt;a href=&#34;http://www.websiteoptimization.com/speed/2/&#34;&gt;Flow in Web Design&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
    &lt;li&gt;Clear navigation&lt;/li&gt;
    &lt;li&gt;Match challenge to skills&lt;/li&gt;
    &lt;li&gt;Simplicity&lt;/li&gt;
    &lt;li&gt;Importance&lt;/li&gt;
    &lt;li&gt;Design for fun and utility&lt;/li&gt;
    &lt;li&gt;Avoid cutting-edge technology&lt;/li&gt;
    &lt;li&gt;Minimize animation&lt;/li&gt;
&lt;/ul&gt;
Web Designにフローを落としこむテクニックはフィードバック以外にも上記のようなものがありますので、みなさんも取り入れてみてはどうでしょうか？
&lt;h3 id=&#34;conclusion&#34;&gt;まとめ&lt;/h3&gt;
&lt;img class=&#34;fig&#34; title=&#34;wp.044-001&#34; src=&#34;/static/blog/2010/11/wp.044-001.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これからもブラウザは進化し続けます。結局、何のためにWebパフォーマンス最適化をするのか？といったことですよね。決して、YSlow のスコアのためでもなければ、開発者の自己満足のためにでもありまん。ユーザーのために最適化するわけです。&lt;/p&gt;

&lt;p&gt;そうしたらやっぱりユーザー（人間）側についても考える必要性があるのではないでしょうか。知覚や認知ついて知れば、それは今後数十年といったスパンで使える知識です。&lt;/p&gt;

&lt;p&gt;そういった知識をWebに落としこむことで、冒頭で申し上げました Long Life Web Performance Optimization は可能になると考えます。みなさんもより良いWeb Developer Lifeにしてみてください。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;fig&#34; title=&#34;wp.048-001&#34; src=&#34;/static/blog/2010/11/wp.048-001.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ありがとうございました。
&lt;h3&gt;参考書籍&lt;/h3&gt;
&lt;table border=&#34;0&#34; cellpadding=&#34;5&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873112710/warikiru-22/ref=nosim/&#34; target=&#34;_blank&#34;&gt;&lt;img class=&#34;fig&#34; src=&#34;http://ecx.images-amazon.com/images/I/51YMPSBD9AL._SL160_.jpg&#34; border=&#34;0&#34; alt=&#34;Mind Hacks ―実験で知る脳と心のシステム&#34; width=&#34;111&#34; height=&#34;160&#34; /&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/Mind-Hacks-%E2%80%95%E5%AE%9F%E9%A8%93%E3%81%A7%E7%9F%A5%E3%82%8B%E8%84%B3%E3%81%A8%E5%BF%83%E3%81%AE%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0-Tom-Stafford/dp/4873112710%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Dwarikiru-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4873112710&#34; target=&#34;_blank&#34;&gt;Mind Hacks ―実験で知る脳と心のシステム&lt;/a&gt;&lt;img style=&#34;border: none;&#34; src=&#34;http://www.assoc-amazon.jp/e/ir?t=warikiru-22&amp;amp;l=ur2&amp;amp;o=9&#34; alt=&#34;&#34; width=&#34;1&#34; height=&#34;1&#34; /&gt;
Tom Stafford Matt Webb 夏目 大&lt;/p&gt;

&lt;p&gt;オライリージャパン  2005-12-01
売り上げランキング : 50592&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.amazon.co.jp/Mind-Hacks-%E2%80%95%E5%AE%9F%E9%A8%93%E3%81%A7%E7%9F%A5%E3%82%8B%E8%84%B3%E3%81%A8%E5%BF%83%E3%81%AE%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0-Tom-Stafford/dp/4873112710%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Dwarikiru-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4873112710&#34; target=&#34;_blank&#34;&gt;Amazonで詳しく見る&lt;/a&gt; by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34;&gt;G-Tools&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Coding Web Performance ~Webパフォーマンス最適化のためのコーディング手法~</title>
      <link>http://localhost:1313/mol/log/coding-web-performance/</link>
      <pubDate>Mon, 06 Sep 2010 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/mol/log/coding-web-performance/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a title=&#34;Coding Web Performance&#34; href=&#34;http://www.slideshare.net/t32k/coding-web-performance&#34;&gt;Coding Web Performance&lt;/a&gt;&lt;/strong&gt;
&lt;object id=&#34;__sse5026478&#34; width=&#34;425&#34; height=&#34;355&#34; classid=&#34;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&#34; codebase=&#34;http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0&#34;&gt;&lt;param name=&#34;allowFullScreen&#34; value=&#34;true&#34; /&gt;&lt;param name=&#34;allowScriptAccess&#34; value=&#34;always&#34; /&gt;&lt;param name=&#34;src&#34; value=&#34;http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=codingwebperformance-100821143443-phpapp02&amp;amp;stripped_title=coding-web-performance&#34; /&gt;&lt;param name=&#34;allowfullscreen&#34; value=&#34;true&#34; /&gt;&lt;param name=&#34;allowscriptaccess&#34; value=&#34;always&#34; /&gt;&lt;embed id=&#34;__sse5026478&#34; width=&#34;425&#34; height=&#34;355&#34; type=&#34;application/x-shockwave-flash&#34; src=&#34;http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=codingwebperformance-100821143443-phpapp02&amp;amp;stripped_title=coding-web-performance&#34; allowFullScreen=&#34;true&#34; allowScriptAccess=&#34;always&#34; allowfullscreen=&#34;true&#34; allowscriptaccess=&#34;always&#34; /&gt;&lt;/object&gt;
※コーダーさんに向けてのセッションでした。&lt;/p&gt;

&lt;p&gt;&lt;h3&gt;Agenda&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#s01&#34;&gt;ビジネスインパクトとスタンス&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#s02&#34;&gt;ボトルネックはどこか？&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#s03&#34;&gt;とあるサイトの改善事例&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#s04&#34;&gt;今日のまとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;s01&#34;&gt;ビジネスインパクトとスタンス&lt;/h3&gt;
Webパフォーマンスがビジネスにおける大きなインパクトといえば、&lt;a href=&#34;http://t32k.me/mol/log/using-site-speed-in-web-search-ranking/&#34;&gt;Googleのランキングアルゴリズムにページの読み込み速度&lt;/a&gt;が組み込まれたことではないでしょうか。2010年4月9日の時点ではgoogle.comで英語で検索された場合にしか適用されません。また、パフォーマンスが考慮された検索クエリも1％未満とまだまだな状況ですが、いずれ日本でも適用される日がくるかと思われますので、今日はそのWebパフォーマンスについて、お勉強をしましょう。&lt;/p&gt;

&lt;p&gt;しかし、このGoogleの評価は何をもって速いとするのでしょうか？公式ブログでは様々な指標をもとに比較検討しています&amp;hellip;とのことでした。一体何を言っているのでしょうか&amp;hellip; とりあえず、分かっている計測基準として2つあるので紹介したいと思います。
&lt;h4&gt;Google AdWords&lt;/h4&gt;
&lt;img class=&#34;alignnone size-full wp-image-1618&#34; title=&#34;key05&#34; src=&#34;/static/blog/2010/09/key05.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;まずはAdWords、Googleの広告サービスですね。実はAdWordsの方では2008年4月の段階から&lt;a href=&#34;http://adwords.google.com/support/aw/bin/answer.py?hl=jp&amp;amp;answer=10215&#34;&gt;品質スコア&lt;/a&gt;の評価にページの読み込み速度が取り込まれていました。品質スコアが高ければ、広告の掲載順位は高くなり、料金も安く抑えられます。この計測方法なんですけども、&lt;a href=&#34;http://adwords.google.com/support/aw/bin/answer.py?hl=jp&amp;amp;answer=93112&#34;&gt;AdWordのヘルプの方にはHTMLのダウンロード時間&lt;/a&gt;と記載されています。現在はまだHTMLファイルだけなんですけども、後々画像やJSファイルといった外部ファイルの計測も行われるようです。スライドの黄色部分に「リンク先ページの読み込み時間に、問題ありません」と書かれています。つまり、もしあなたの会社がAdWordsに出稿しているのであれば、Webパフォーマンスは既に対処しなければならない案件になっているということです。
&lt;h4&gt;Google Webmaster Tools&lt;/h4&gt;
&lt;img class=&#34;alignnone size-full wp-image-1621&#34; title=&#34;key06&#34; src=&#34;/static/blog/2010/09/key06.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次にウェブマスターツールなんですけども、2009年の12月に「サイトのパフォーマンス」という項目が追加されました。これは文字通りサイトの読み込み速度に関する情報が表示されます。では、何をもって速い・遅いとするのかですが、このツールではGoogleが収集したデータの上位20％が早く、残りの80%が遅いと決めているようです。そのラインが平均読み込み速度が1.4秒、スライドの赤いラインです。そうゆうわけで、私たちの目下の目標としてはこの1.4秒以下に読み込み速度を抑えるということになります。こちらの計測方法ですが、Googleツールバーをインストールしたブラウザでなおかつページランク機能を有効にしたユーザーの読み込み込み時間となっています。AdWordsの方はHTMLファイルだけの読み込み時間ですが、こちらは実際の状態に近い計測手法となっています。&lt;/p&gt;

&lt;p&gt;そんなわけで、ほかにもいろんな計測をしていると思うのですが、とりあえずはこの2つを意識して対策をしていけば良いでしょう。
&lt;h4&gt;高速サイトがもたらす利益&lt;/h4&gt;
高速サイトがもたらす利益としては、検索だけではありません。ベージが速く読み込まれればそれだけユーザのストレスがなくなるわけですから、再訪問数の増加やセッションあったりのPV数増加にもつながります。そうすればおのずとコンバージョン率の改善、そして収益増加。また、売上が上がるということは顧客満足の向上した結果とも言えます。そういった売上の増加だけでなく、ページをコンパクトにまとめることでサーバーの転送量が少なくすることができれば、インフラコストや帯域幅の節約などにもつながります。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-1622&#34; title=&#34;key08&#34; src=&#34;/static/blog/2010/09/key08.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;さて、こういったビジネスインパクトがコーダーに与える影響の面を考えると、コーダーはパフォーマンスという武器を手に入れることになるのではないでしょうか。というのも、デザイナーもそうですが、ただ単純にキレイなデザイン・キレイなコードというのはクライアントさんや、その上のマネジメント層にとっては興味のないことであって、彼らが知りたいのは売上です（そもそも彼らの仕事は数字を見ることですからね）。ですから、商品をできるだけ目立たそうとして、デザイン的に無理な要求であったり、例外処理ばかりのコードになることも多々あります。そこで、私はデザイナーとして「トーンアンドマナーが&amp;hellip;」など言うのですが全然聞いてくれません。ところが隣のSEOチームが「いや、それはSEO的に良くないのでやめて下さい」と言えば、素直に従ってくれます。これはまぁ、SEO的に悪い＝検索順位が下がる＝売上が下がるといった思考パターンですよね。つまり、今回WebパフォーマンスがGoogleのランキングアルゴリズムに組み込まれたということで、その程度はどうであれ、SEOとパフォーマンスを絡めることができる。そしてパフォーマンス対策できるコーダーの存在感が高まるのではないでしょうか。社内の存在感が高まれば、それだけ自分の好きなこと・やりたいことを貫ける可能性も高まるのではないかと私は考えます。&lt;/p&gt;

&lt;p&gt;とはいえ、コーダー・デザイナーは忙しいです。HTML5/CSS3は次から次へといろんなAPI、プロパティが出てきています。最近、jQueryナウいよねってことでJavaScriptを多用すれば、アクセシビリティやユーザービリティに関しても気を使わなければなりません。またサイト全体の情報アーキテクチャも考えなければならないし、アクセス解析も嗜みたいところ。そこで、今回取り上げるWebパフォーマンスですか？それはちょっと、無理無理カタツムリよーってことで。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-1623&#34; title=&#34;key11&#34; src=&#34;/static/blog/2010/09/key11.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;とはいえ、来週あなたの上司が「パフォーマンス対策はどうなっとらんやー！」って聞いてきたらどうしましょうか？HTMLのコード量を減らしましょうか？JSの変数名やCSSセレクタを短いものに置き換えていきましょうか？そういった明後日の方向に進まない（まず最初に取り組まなければならない問題ではない）ためにも今回のセッションの目的は&lt;strong&gt;最小限の対策で最大限の効果&lt;/strong&gt;をあげれるような対策を紹介します。
&lt;h3 id=&#34;s02&#34;&gt;ボトルネックはどこか？&lt;/h3&gt;
最小限の対策で最大限の効果をあげるためには、ボトルネックを探しそれを取り除いてあげればいいんですね。とは言っても、Webパフォーマンスという目に見えないものを対策するにあたって、それをビジュアライズするツールが必要になってきます、それが、この&lt;a href=&#34;http://www.httpwatch.com/&#34;&gt;HTTPWatch&lt;/a&gt;です。こういったツールは他にもFirebugの接続パネルやSafariのリソースパネルなどがありますが、HTTPWatchはWindows上でIEとFxで動作するので採用しています。&lt;/p&gt;

&lt;p&gt;このツール最大の機能はウォーターフォールチャートです。これが何を表しているのかというと、ページの読み込まれ方を表しています。この1つ1つのバーがページのコンポーネント、画像であったり、CSS、JSファイルであったりページの部品を表しています。横軸が時間経過を表しているのでこれが横に長ければ長いほど読み込み時間に時間がかかかっているのが読み取れます。とは言っても、バーの赤色とか緑色は何を表しているの？って感じですよね。&lt;a href=&#34;http://t32k.me/mol/log/httpwatch/&#34;&gt;HTTPWatchのヘルプ&lt;/a&gt;には以下のように記載されていました。
&lt;ul&gt;
    &lt;li&gt;ブロッキング&lt;/li&gt;
    &lt;li&gt;DNSルックアップ&lt;/li&gt;
    &lt;li&gt;コネクト - 接続&lt;/li&gt;
    &lt;li&gt;センド - 送信&lt;/li&gt;
    &lt;li&gt;ウェイト - 待機&lt;/li&gt;
    &lt;li&gt;レシーブ - 受信&lt;/li&gt;
    &lt;li&gt;キャッシュ読み込み&lt;/li&gt;
&lt;/ul&gt;
&lt;img class=&#34;alignnone size-full wp-image-1626&#34; title=&#34;key17&#34; src=&#34;/static/blog/2010/09/key17.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用語だけ言われても分かりませんので、具体的に見ていきますと。まず、サーバーとクライアントであるブラウザがあります。例えばCSS Niteの公式サイトを見たいとするのならば、ブラウザのURL欄にcssnite.jpと打ち込むでしょう。そうすると、ブラウザは打ち込まれたURLをIPアドレスに変換するためにISPなどに問い合わせにいきます。そして問い合わせた結果が届いた時間までが&lt;strong&gt;DNSルックアップ&lt;/strong&gt;です。次に、そのIPアドレス上にあるサーバーに接続を試み、うまく接続できたならばOKのレスポンスを返します。ここまでが&lt;strong&gt;コネクト&lt;/strong&gt;です。ソケット接続とかTCP接続などと呼ぼれる部分です。この部分は持続接続可能なので2回目以降は省略されます。そして次がもっとも大事なHTTPリクエスト。cssnite.jpのindex.htmlなどのリソースを探しにいきます。そしてサーバーがこれねこれね、ということで見つけたリソースの最初のパケットデータが届いた時点が&lt;strong&gt;ウェイト&lt;/strong&gt;です。そして残りのデータをすべて送りブラウザに届いた時点が&lt;strong&gt;レシーブ&lt;/strong&gt;です。このレシーブが一般的にファイルのダウンロード時間と考えらています。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-1625&#34; title=&#34;key15&#34; src=&#34;/static/blog/2010/09/key15.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このことをふまえて、もう一度先ほどのウォーターフォールチャートを見て見ますと、どうでしょうか？何色が目立ちますか？どう見たって赤色ですよね。Webパフォーマンスと言われるとファイルのダウンロード時間を短くすればいいんじゃね？と考えがちなんですが、この場合、緑色の部分はなんてほとんどないですよね。そもそもこのウォーターフォールチャートはどこのページを読み込んでいるかというと、後ほど紹介するとある一般的な企業サイトです。どのコンポーネントも数キロバイトの画像です。このスライドから読み取れるに、4キロバイトの画像も5キロバイトの画像もダウンロードにかかっている時間はそう変わらなくて（だからと言って画像の最適化を怠ってはいいということではありません）、ダウンロード時間の何倍もの時間をウェイト時間に費やされているのが分かります。ウェイト時間はサーバーの待ち時間なので、私たちデザイナー・コーダーにとってはどうしようもできない部分です。必ずかかる税金のようなものです。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-1627&#34; title=&#34;key20&#34; src=&#34;/static/blog/2010/09/key20.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;この仕様をとあるハンバーガー屋さんで例えてみますと、レシーブ時間をハンバーガーを作る時間、ウェイト時間をお会計にかかる時間とします。さらにこのお店は一回の注文につき一つの商品（リクエスト）しかできません。つまりチーズバーガーが2個欲しければ、チーズバーガー１つくださいと言って、作ってもらってお会計をして、またチーズバーガー一つのくださいと言って作ってもらってお会計するというようなめんどくさいことをしなければなりません。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-1628&#34; title=&#34;key21&#34; src=&#34;/static/blog/2010/09/key21.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;もう一度、先ほどのウォーターフォールチャートを見てみますと、これは実はIE6で読み込まれたウォーターフォールチャートです。ここにはもう一つ重要なことが隠されていてます。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-1629&#34; title=&#34;key22&#34; src=&#34;/static/blog/2010/09/key22.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;とりあえず、この同じページをFirefox3.6で読み込んでみますとこのようなウォーターフォールチャートになりました。皆さん、一体どこが違うでしょうか？ここでは、バー1つ1つの長さは比較対象にはしていません。それよりも、なんだかコンポーネントの読み込まれ方が違いませんか？どうやらIEのほうはなだらかに読み込まれていて、Fxの方は急な勾配になっているのが分かりますね。これがどういった違いによるものかと言いますと、
&lt;h4&gt;ホスト名毎の同時接続数&lt;/h4&gt;
&lt;img class=&#34;alignnone size-full wp-image-1630&#34; title=&#34;key23&#34; src=&#34;/static/blog/2010/09/key23.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ホスト名毎の同時接続数によるものなんですね。HTTP/1.1の仕様ではひとつのホスト名（www.cssnite.jpのような完全修飾ドメイン）に対して同時接続できるコンポーネントは2つまでと決まっています。実際のブラウザの実装はどうなっているかと言いますと、FxやChrome,Safariなどは6や5つ同時接続できるのですが、ここで着目してほしいのはIE6,7のようなシェアの高いブラウザのが2つだという点です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/static/blog/2010/09/key24.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-1631&#34; title=&#34;key24&#34; src=&#34;/static/blog/2010/09/key24.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;先ほどのウォータフォールチャートを見てみますと、実装どうりの挙動をしているのがわかりますね。より多く同時接続できている方が早いです。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-1632&#34; title=&#34;key26&#34; src=&#34;/static/blog/2010/09/key26.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これをふまえた上でもう1度ウォーターフォールチャートみてみますと、このIE6のなだらかな階段状になっているのは冒頭で紹介したブロッキング時間（灰色の部分）に時間を費やされているのががわかります。サーバーに同時接続できるのは2つまでなので、それ以降のコンポーネントはダウンロードが完了するまで待たなければいけません。そしてダウンロード完了すれば次のコンポーネントが1つだけ接続されて、また次のコンポーネントは待たなければいけない。つまり、接続出来ていないコンポーネントは順番待ちをしている状態です。一番最後のコンポーネントを見ますとかなりの時間を順番待ち（ブロッキング）に時間を費やしているのが読み取れます。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-1635&#34; title=&#34;key28&#34; src=&#34;/static/blog/2010/09/key28.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;この状態をまたとあるハンバーガー屋さんで例えてみますと、先程紹介したお店は1回の注文につき1つの商品しか頼めません。しかも、このお店はレジが2つしかないんですね。ですから、当然大勢のお客さんが群がれば（大量のコンポーネントをリクエストすれば）待ち時間が多くなる。当然、ページの読み込み時間も遅くなるということです。&lt;/p&gt;

&lt;p&gt;つまり、ウェイト時間とブロッキング時間から、&lt;strong&gt;HTTPリクエストは非常にコストが高い&lt;/strong&gt;ものだということが理解できます。
&lt;h3 id=&#34;s03&#34;&gt;とあるサイトの改善事例&lt;/h3&gt;
ボトルネックはHTTPリクエストだということが理解できたので、今度は実際にどのようにHTTPリクエストを減らしていくのか、とあるサイトを例に考えていきましょう。&lt;/p&gt;

&lt;p&gt;改善手法として使ったのは以下の5つです。
&lt;ul&gt;
    &lt;li&gt;CSSスプライト&lt;/li&gt;
    &lt;li&gt;データURIスキーム&lt;/li&gt;
    &lt;li&gt;CSS,JSファイルの結合&lt;/li&gt;
    &lt;li&gt;CSS3プロパティ&lt;/li&gt;
    &lt;li&gt;奥の手&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;CSSスプライト&lt;/h4&gt;
まずは、CSSスプライトなんですが皆さんも使ったことがある人は多いのではないでしょうか。CSSスプライトを改めて紹介しますと、複数の画像を1つの合成画像としてグループ化して背景の位置指定を使って表示する方法です。簡単に言えば、1つの画像を使い回ししているのですね。例えば、通常であればグローバルナビメニューなどは各メニューごとに画像を切りだしてコーディングしていくと思うのですが、そうしてしまいますと、先程言いましたようにその画像1つ1つにHTTPリクエストが発生してしまいます。それでは良くないので、全部まるっとまとめちゃっいますと、それだけHTTPリクエストが減らすことができます。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-1638&#34; title=&#34;key35&#34; src=&#34;/static/blog/2010/09/key35.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;実際どうなのかというところをHTTPWatchで確認してみますと、私の環境ではスプライト前とスプライト後では150msも変化が置きました。使っている画像も同じでコーディングの仕方を変更するだけでこれほど違いが出るのはとても有効な手段かと感じます。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-1639&#34; title=&#34;key36&#34; src=&#34;/static/blog/2010/09/key36.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;そう考えますと、CSSスプライト最強じゃね？全部スプライトしちゃえばいいんじゃね？って考えがちですが、スプライトのジレンマというのがあります。ページ数、保守性、最適化。スプライトをする上でこの3つの中から2つしかとれないんですね。例えば、多くのページ数を保守性を保ちながらスプライトすると、最適化はちょっとあきらめなければいけない。また、多くのページ数を可能な限り最適化すれば保守性はごめんってなります。はたまた、保守性を意識しつつ最適化すれば、適用できるページ数は少なくなってしまいます。&lt;/p&gt;

&lt;p&gt;先程の改善事例もHTTPリクエストを可能な限り少なくするには全部まとめれば良いのですが、それではグローバルナビに変更が起きた場合、関係ないローカルナビの位置も変更しなければならない手間も増えてしまいます。ですので、この改善事例の場合は3つのグループに分けて運用しています。&lt;/p&gt;

&lt;p&gt;とはいえ、HTTPリクエストはスプライトを適用する前から11-&amp;gt;3になったので8つも減らすことができました。
&lt;h4&gt;データURIスキーム&lt;/h4&gt;
&lt;img class=&#34;alignnone size-full wp-image-1640&#34; title=&#34;key38&#34; src=&#34;/static/blog/2010/09/key38.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次にデータURIスキームですが、これは画像ファイルをリクエストすることなく画像をマークアップ中に埋め込むことできるシロモノです。一体何を言ってるのか分かんねぇと思うが、起こったことをありのまま話すぜ。まぁ、上記のスライドを見ればわかると思います。単にリソースのパスを書けばリクエストしにいっちゃいますんで、そうではなくて長ーい文字列に画像を変換しているのですね。このような変換は&lt;a href=&#34;http://t32k.me/mol/log/data-uri-scheme/&#34;&gt;オンラインの変換ツール&lt;/a&gt;がありますので、利用すれば良いと思います。&lt;/p&gt;

&lt;p&gt;これまたデータURIスキーム最強じゃね？って思うのですが、これにも弱点がありまして、まずIE7以下が非対応であること。改善事例のサイトでは残念ながらこのようなブラウザに対してはCSSハックで分岐処理して通常の画像を読み込ませています。次に、サイズ制限の問題。一番厳しいOpera7.2で4.1KBとなっています。なので、データURIスキームを適用できるのはアイコン画像のような比較的小さな画像だけと考えておきましょう。&lt;/p&gt;

&lt;p&gt;そんなわけで、データURIスキームのおかげでIE7以下以外は HTTPリクエストを1個減らせることができました。
&lt;h4&gt;CSS,JSファイルの結合&lt;/h4&gt;
これはそのままです、単にまとめるだけです。例えば、事例のサイトではリセットCSSにYUIのreset.css,font.cssを使用し、プラス、ページの構造を記述したCSSを使ってました。これでは3つのリクエストが発生してしまいますので、全部まとめてcommon.cssなどにします。また、JSファイルもjQueryを読み込んでいたのと、そのプラグインJSを2つほど読み込んでいたのでこれもまたcommon.jsにまとめちゃいました。このサイトは僕1人で運営しているので、これで特に問題ないのですが、中・大規模サイトであれば複数人でのコーディングが考えられますので、ファイルのバッティングなどの問題があります。今、俺触ってるから君触っちゃだめ！みたいな。そうゆう場合は、PHPのinclude文など使って擬似的に@importを再現すれば良いでしょう。ただ@importすれば、それはHTTPリクエストしたことと同じですので注意が必要です。&lt;/p&gt;

&lt;p&gt;そんなわけで、HTTPリクエストは6つから2つに。4つ減らすことができました。
&lt;h4&gt;CSS3プロパティ&lt;/h4&gt;
&lt;img class=&#34;alignnone size-full wp-image-1642&#34; title=&#34;key43&#34; src=&#34;/static/blog/2010/09/key43.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;CSS3は事例のサイトでは使ってはいないのですが、来るべき時代に備えときましょう。ここであげたプロパティに関して共通して言えることは、今まで画像を使わないと表現できなかったことがCSSのコード数行で実現できる点です。とはいえ、ここにいない子のことを考えますと、そのようなブラウザに対してどのような対応していくのかサイトオーナー、方針などともに考えていく必要性があるでしょう。
&lt;h4&gt;奥の手&lt;/h4&gt;
今まで、4つの対策を見てきたのですが、どれもなにかしらの弱点があります。非常にコマッタピョンです。なにか一発お手軽簡単な方法はないかなーないかなーとt32k考えました。考えた考えた上でデザイン変えればいいんじゃね？（※コーダーさんに向けてのセッションでした）&lt;/p&gt;

&lt;p&gt;これはちょっと冗談でなく、実体験からの考えです。&lt;a href=&#34;http://t32k.me/mol/log/introduction-to-web-performance/&#34;&gt;WDE2009でNicole Sulivanさんのワークショップ&lt;/a&gt;に参加しました。そこで僕は今回の改善事例のサイトを題材にパフォーマンスに関してアドバイスをいただきました。そこで言われたことは「JSファイルが重いようだけど、どこで使っているの？」と問われ、スムーススクロールを実現するためにjQueryとそのプラグインを読み込んでいますと言うと、「コストをかけすぎじゃない？」と言われました。彼女は元はJavaのエンジニアで、そういったエンジニアの方からデザイン・振る舞いに関して何かを言われたということはあまりないことでとても印象的でした。というか、ちょっと凹みました。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-1643&#34; title=&#34;key47&#34; src=&#34;/static/blog/2010/09/key47.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;そこで、帰ってもう1度対策を考えてみました。まず、指摘されたスムーススクロール。これは長いページでページ内遷移する場合、通常であれば瞬間的に移動するのでページ遷移したと感じてしまう可能性があるので、ゆっくりスクロールして移動することでページ内遷移であることを示す効果があります。とはいえ、改善事例のサイトではそのような必要性があるような長いページもほとんどありませんでした。また、本当に使われていないかGoogle Analyticsで「このページの先頭へ」というリンクがどれほどクリックされているのか計測してみたところ月で数回程度、このサイトは月間2万PVあるので、ほとんど使用されていないことが分かりましたので、不採用としました。&lt;/p&gt;

&lt;p&gt;また、検索ボタンの画像も、画像だからといって検索されやすいこともないだろうと考えブラウザデフォルトのSubmitボタンに変更しました。（これも月数回程度の利用率だったので）&lt;/p&gt;

&lt;p&gt;一般的にWebデザイナーというのはビジュアル重視しがちであまり数値を気にしない職種かもしれません。（かもねかもね.. ）そこでコーダーさんは今回Webパフォーマンス対するコスト意識を学んだので、それをデザイナーさんに説明することでデザインを変更してもらうというのも１つの手段になるかと考えます。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-1644&#34; title=&#34;key49&#34; src=&#34;/static/blog/2010/09/key49.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上のような対策をしてきた結果、冒頭で紹介したこのサイトのパフォーマンスは常時、1.4秒以下に抑えることができました。もう少し詳しく説明しますとトップページのHTTPリクエスト数は32から17に減少。平均読み込み時間は0.5秒。Googleが収集しているデータ全体の中で上位2%にはいる高速サイトとなりました。（2010/4/8）&lt;/p&gt;

&lt;p&gt;今回の対策にあたり、私はHTMLを1から組み直したわけでもなく、サーバーの設定をカリカリにチューニングしたわけではありません。当初の目標に設定したとおり、HTTPリクエストを減らすという最小限の対策でこのような最大限の効果が得られたと考えています。
&lt;h3 id=&#34;s04&#34;&gt;今日のまとめ&lt;/h3&gt;
&lt;a href=&#34;http://t32k.me/mol/log/performance-business/&#34;&gt;Webパフォーマンスがビジネスに与える影響は非常に大きなもの&lt;/a&gt;ですので、それをうまく利用することでコーダーさんの武器にしてください。&lt;/p&gt;

&lt;p&gt;パフォーマンスをあげるにはHTTPリクエストを減らすことが一般的に最も効果が高いと思われます（そうでない場合はHTTPWatchなどのツールを使って検証してみてください）。ボトルネックはHTTPリクエストです。&lt;/p&gt;

&lt;p&gt;しかし改善事例から学ぶに、 HTTPリクエストを減らす、1発簡単お手軽な方法は皆無です。それぞれ何かしらの問題を抱えています。そこでこれ以上減らすことができないのであればデザイナーさんに相談してみるのも1つの手でしょう。&lt;/p&gt;

&lt;p&gt;反対にデザイナーはなぜそこで画像を使わなければならないのか？なぜそのデザインなのか？という説明責任を果たす必要があります。&lt;/p&gt;

&lt;p&gt;長々、喋ってきたましたがコーダーさんもデザイナーさんもエンジニアさんも仲良くWebパフォーマンスに取り組んでいけたら幸いです。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-1646&#34; title=&#34;key54&#34; src=&#34;/static/blog/2010/09/key54.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;352&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ありがとうございました。
&lt;h4&gt;参考書籍&lt;/h4&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/gp/product/487311361X?ie=UTF8&amp;amp;tag=warikiru-22&amp;amp;linkCode=as2&amp;amp;camp=247&amp;amp;creative=7399&amp;amp;creativeASIN=487311361X&#34;&gt;ハイパフォーマンスWebサイト —高速サイトを実現する14のルール&lt;/a&gt;&lt;img style=&#34;border: none !important; margin: 0px !important;&#34; src=&#34;http://www.assoc-amazon.jp/e/ir?t=warikiru-22&amp;amp;l=as2&amp;amp;o=9&amp;amp;a=487311361X&#34; alt=&#34;&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; /&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/gp/product/4873114462?ie=UTF8&amp;amp;tag=warikiru-22&amp;amp;linkCode=as2&amp;amp;camp=247&amp;amp;creative=7399&amp;amp;creativeASIN=4873114462&#34;&gt;続・ハイパフォーマンスWebサイト —ウェブ高速化のベストプラクティス&lt;/a&gt;&lt;img style=&#34;border: none !important; margin: 0px !important;&#34; src=&#34;http://www.assoc-amazon.jp/e/ir?t=warikiru-22&amp;amp;l=as2&amp;amp;o=9&amp;amp;a=4873114462&#34; alt=&#34;&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; /&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/gp/product/4873114314?ie=UTF8&amp;amp;tag=warikiru-22&amp;amp;linkCode=as2&amp;amp;camp=247&amp;amp;creative=7399&amp;amp;creativeASIN=4873114314&#34;&gt;オプティマイジングWebサイト —SEO・サーバ・クライアントの最適化技術&lt;/a&gt;&lt;img style=&#34;border: none !important; margin: 0px !important;&#34; src=&#34;http://www.assoc-amazon.jp/e/ir?t=warikiru-22&amp;amp;l=as2&amp;amp;o=9&amp;amp;a=4873114314&#34; alt=&#34;&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>データURIスキーム</title>
      <link>http://localhost:1313/mol/log/data-uri-scheme/</link>
      <pubDate>Wed, 07 Apr 2010 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/mol/log/data-uri-scheme/</guid>
      <description>&lt;p&gt;今回の記事の主題はデータURIスキームとはなんぞいねってことなんですが、簡単に言いますと、このスキームを使うとサーバにリクエストすることなく、ページ内のコードに画像を埋め込むことができるという話です。スキームといえば、このほかにもhttp:、ftp:、mailto:なんてものがありますね。&lt;/p&gt;

&lt;p&gt;ウェブパフォーマンスにとって高コストなものといえば、HTTPリクエストですから、それを使わず画像を表示できるということはこのスキームを使う最大のメリットと言えるでしょう。&lt;/p&gt;

&lt;p&gt;てなわけで、実際にどんなものか見てみましょう。例えば、隣にあるこのフィードアイコン&lt;img src=&#34;http://www.feedburner.com/fb/images/pub/feed-icon16x16.png&#34; alt=&#34;&#34; /&gt; はHTMLソースの中ではこんな感じでに記述されています。
&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;ldquo;&lt;a href=&#34;http://www.feedburner.com/fb/images/pub/feed-icon16x16.png&amp;quot;&#34;&gt;http://www.feedburner.com/fb/images/pub/feed-icon16x16.png&amp;quot;&lt;/a&gt; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;
これをデータURIスキームを使って表現するとこんな感じになります↓
&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;ldquo;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAKOSURBVHjadJNNSFRRGIbfc+6dO6OOOplDykSZaRCtnKRc+ANRUBFEm0gicxG0bGoVhERRYIvIjRAtW+UmW5QQQS6qRWQSWJRaUcjkT0LiVWfm/pzTd869M5LShe+eufC973m+n2Fj55KJymTt9ZgVy3AGMHoxvvEs/qZgDL4AlhbsAfv34g1TiRPxRMZbWwU3GQzO9clNhGcYBpkY4UlGiWRd5scnMvx5tUWano9IMoXy1pOUBPgz4xC/xv8r1hSexNKiB1Nhq6RIbQoVhy6i+MiCDffDEPyJITBvZZPYLwiQFFzVZ0Q45Moc8q8fwP34FGJ5FixaCevgBZT1DMNs7Nok9iikL8GyfWkZ3VgvhbljP6yOy2BbmzWR/+o2vM/PSmLfkchTaAIlsHa1ourSS5Sfvg8r3Q38mYb7+DzE9Ig2MDquAan2kth3AgKu0JSBapLCNranEWnPIHp2GDzZDEE3+1OBiXW4D4LHtViZCB/rBHJuHPmHp+CO3oK0Zyk7DvP4IGR1EwrPb673JX0mELslgvVRYW0O8usIvCe9AboyOdIPn1Ug9+Kupihr69ZiZSJFsYRwztbRO4icGARv6IT3ZkCTsKp68J2dyE2MQuZtsFgllbZHTyMsAVqsaldCVt8CtvsYPHsZzvtH+tZIc5e+sfBtLOhFYytRFAlYuGGED2clGNn8lO62m53U37y6XmM7M8E3onEIIpCSLp/vPyC31Bp6SUSsjmIbnO9jpVEZqbROzn15F5RDZs5CFs58FmaNBTZ5Ze+9hn11Genl/1mS0qjChumaCVvo2iViNXHkuD1g9Daxt7lVEQPMNpcSdah1pQb5kqho4yVXQc2iacHiMMpNFPia/jv/FWAAUTVTOunExzkAAAAASUVORK5CYII=&amp;rdquo; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;
なんかわかりませんが、わっさー長くなりましたねw これは画像のバイナリデータをBase64で表現したものになります。はい、よくわからんですね&amp;hellip; バイナリというのは&lt;a href=&#34;http://e-words.jp/w/E38390E382A4E3838AE383AA.html&#34;&gt;文字データ以外のデータ形式全般のこと&lt;/a&gt;と書かれていますが、映画のマトリックスに出てくる数字の羅列みたいな感じを個人的には想像しています。まぁ、それをBase64ってゆう形式で表現し直しているって感じでしょうか。Base64に関してはこちらを参照↓
&lt;blockquote&gt;Base64は、データを64種類の印字可能な英数字のみを用いて、それ以外の文字を扱うことの出来ない通信環境にてマルチバイト文字やバイナリデータを扱うためのエンコード方式である。
&lt;a href=&#34;http://ja.wikipedia.org/wiki/Base64&#34;&gt;Base64 - Wikipedia&lt;/a&gt;&lt;/blockquote&gt;
そういうわけで、より大きな画像をBase64に変換すればそれだけ結果も長く、容量が大きいものになります。例えば、先程のアイコンよりも大きいこのCSS Niteのバナーを変換してみましょう。
&lt;img src=&#34;http://t32k.me/mol/wp-content/uploads/2010/03/lp9.png&#34; alt=&#34;&#34; /&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;ldquo;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAACTUExURd9+g++ws+WVmdu8qNiDgOerqvvx8NlwdvfEyNltdN+JivLT0Nt4fPXd2+Oamt14fuKKjttzefjn5fS9wdieku3Avt2Ag+uipvG2uu/Kx9huc+SQlOGRkuajotvRuOu2tNiRiemcoOCEie2prdvDrdh8e9d1d9utndu1otvKs9qmmNiKhNmXjdvYvf////rLz9dmb3ITzt8AAA/GSURBVHja7VvnYrLMEgYVkKZYwB5rNO1F7//qDmyvgJCi32H/BGGZnWf67BLj9h8ZRgukBdIC+X8GYjzwGFUE4q6O/etjj/nsUApkNLs+xZhExUA6v8yPGRn7mvqfD/VAXBPNWRkuczdCS/VnB8E+R3ssoJVoosYcr3gc3tzOdbIHxj0y9hPKzCqfOczIzxW2Qqlf5x3WMzBDkQ6IC9c2hyLFIWTIVSwGVNhfKZ4gatcjZIp5csBQJvB3dJ24ageGBmIaaoZ4JMwksHJfJZsZlp7Mbv7KUPkogqspHrrIEfdI8tdIE1JdHUNHGQkFAhSpZiqTzEyzVmaNmlRkwMWUzyCSGQaiTWZzyRU4X2a5Nbh1NcLdX/sa5d/6WohFQKBIiWkddED6GoZwbDUVQMyr3n4mRdzqxHksAuL2iUoyZz9qqUcFb/PGZbD+M1G/drzqrNjo6zglkbzwsdnpzHKmOhrqppqhOQ3CEpAZh8+N9iYZ+Upomsvczsac4fRw5B6RIMt4/97cR7xQSR6ZwLewKWPqdPpqRmmz6WQoAgEL4yAZSUkKTRseWXQcpyvlOhTICIpx7jKS2+M8IkwmJPDkVfaiLKMrq0sDRw7Gsg5yHpXd0T2YOtsZrSYyEFPwz4hxdh0QkzA0HymTLePuBhNiTDah8GOvtOGJJlGwtQ4fw+h8g8kjOiA4CEyEjDmiSpwIQFYst6oiTe91+6LgS3jrSMbAXmmAdHBe7GjCL6Nxg1mnoweiiSu5aDShfqUxexLJqwMxpBDfKQZSoBFdAO6w/suPiQaI+aMaiUp8JKeq4nekrc+w1JoA0fnI8KoFYpRELfC4ozAi3Fe4JSVKLSBzTdRiguJcAOJei/MIZQONlcTgBD8afhsQkkcyhvrqPHVUJsQVzewdPrMzfIIxMxgznHOPsAl+BxB9qcH1ZiyQfXGtpYlaORN9TdV4+AYgk7JaixgRATK6Fla/uvp0qK9+998ARMdQX7IsWsbPrto0nfGk6xhm2vIWL9YMSEk/wkjR4NO+rkM0tAq5FiukAhC3AIi+ZRUUwrS6MBUrNxJmmnQICle3MLFjHU/EgHlgr7STi3t2tm81JH0pNy0m2i0UZfM4OgrxMZJqBBPX1K5Uy0ZCxDc0KYrTlqGwPNU2krjzxGxQHQXtDyNuuzLLKyN+468zuhnAevrZ1WFePFnB0Aq6Xz/S7jTur080BO8xFB3GUwxxv1C0v+g5oByN8vORYcd8bDDmLBq1R28tkBZIC6QF8phAhqtOpzOsSQu8XDiiKnIbGvKLK93xuhoIrlAmdfRkmNVOY1dFLLmR9pS/fyx805BP/a4FLbp+RNVT80yn8tJTftOoAoRjZfVzOHIoqvbGrVJ8a6EY/Kah4gSl0hjdW4MbytOvKmPvlgAR1Hq8C8j9X36s9PvSZV7mFgMRBXIXkBrfYcxqS0K5IWGoNoaFnZbvtyxJJ/d9BKNCYkgnM3WAGLUaC0PclWxiXX8JhGzNuHdbpvlQQEi26lwbx4q/BYI22NwaoaI/eiQgSK5RnVdnDwVkzm6A3jmGjwQEHm/U+xhw9lBAorpJSNo9/2MgncYO9sNADHWz0VflA+nlfG9bbNkmZbnkN4Eo6iAlkEPRwZGuGvxdINK3CBPVy6tbNSTGHwLZK6RqqM5DyBgyR7JFgH8ZyKwSEN5jZiPhNE/Zj/8ykIkiI7ql5Uik7hXMvwMSKXmZVEo3cuL8DSAr1X9+HGbqEDqrWI+YfwDkrkK+QltlPjqQw62abYGi7JGBuFXr+MNjAznK32wU2OADA8FH/qP+cwOZVCfw2KbFfIMR9Z/Y2TlGhpOnDb/CRoh7fNaEKH+FMX+8EuU+B6Fbp8dHKxrr7ajn3EaziaaM7/xFGV/q54VnmyPjYRqrSg3GfeNvWt3CNLhya+Do/M3mg96m9nVO8RttB5UbiElEW62xMgpO/Y3Z/Kc26O4x9kbqvNH/2/6OLVO3VpWBtpIbAnEntVdWnOo2qcQbApl/Q2FAf5r1gIBTp2ZAOtfmCpG+ja+3Kd4MSJ3zEf3RW+1jCrMpkGHzM4Wb6iP/Om3er1ecZtHXQXVV8gdAij4YqOt0QDijvy+djcZhcNb0i5zRd+Dggbh1kBwafyNlNrYr6ePMGkjmKqnelw/vs63SD8/KdwCK1BxpW7darYbeI8s/BcQbTJN65sog2d9dps+awlB+wBxV1wr7kSX51vZQo+E4VBCfWflzWeZu6afI4HNkgfCw0+DrZ6N4LaOMbvttfAukBdICaYG0QFogLZAWSAukBfJfABLEdppuf2IxZ7MhV4MfB2KlYDReaJuOA+FWmKYeuUp+GEgMcaR2oH9p4y9K2VhnNCz+1iDFQOhVkSDCJkAwDokLgSG/jPBY1uoiuxWQK6cMR5o2ALImOApYjSsA8VKZ18z1xuJV0ft+fSCODXQR5H6y0L7jF+qLghUpZLdicoWiydqPtWus6wPZIjd3sj+bQiAli+QERC/wiLF5hEB+pXK3JC3VWRGQgPhG5ml6G7bLXXWjsAze1xOiOE+j0G19IFsqB0+PI5dWWsHVPQVzoiNnXh/q3l/XBgI8RHrdEzA5oQZI4olxzUmELGIT20TySqyNSmIBCRWBp0oDXlIIJF8+FLN8TpLNbINcWHSaswnTseVAgce8QDN6rIESa3MogYSFEQwsK3E8KwDBM0S6s/FTK0xDC4tyUATEl0L/wIahGMcfZ8vfcCz4O0SBe0CD+BiaoMdbZP4zybNImmsi48ima/k48NugushAB0D5AVwZPotx7ZHogQRS6B+QpAINbmPz2TIJ8e8Bqmy2lrWB+c4CcmHWo8RI6bCgNkpJ5UAWwNc9G/7KH5OVEyjw1LYsa60GIiVsD0o7xSGAZn0oaGfMlAFWSpfa5ja1SXlfsgQg6cajsYVDGQNWxzGVWWCzBceCIlYC2Qp5DvAZJtAmAoQjHABzC3ChMfZyJ86SDgskc1EHrc0XKJxGnJhkK4TDh9YV3MbMPAfGiTT0HBTLyoCIeS4X6dhBDzzoBDETPIFHOjDWBVRdCya2saY65mHEzo1IBIjKzr1mCwlw6oHKzOYHAD6EJZWDBhceudhPfoOsBfj12dg/hmS3UK42ssKxwxWfFpfrychneQR1mOL4toDEUs6IHVSaLaCkA2zwvsbZBV8PSJDMZZkMSACxoZgGkM0BZAc42JoErpg1NOJw4wRboIU0OyBh3yFemSDntD0EwIITcbbPf1pbUkmrgSQoZG+YhiIB1hjikg+XTAAeoJqLNze/POnY1ObHYzZyW8hwLRIFQ8wLuYA1K44y6wBxnt91HFxzQ/2EYgkkAAGmlPsp9F4PB4H4RhQSQ8UBhrYhlDNAvc2xLQiODYqTTIESEGYDRuMJhgv9KkS0LUBmDX01tcZIbWDSIJAKcIOvBTfY6ykQsLJHQqUH1nJoDMqpg4gfJIg6UGGCLcWjoYRcpChW5Cp2sMl4Y9wHLSAe2IgNmDiHVgpJAbq2bUcZtRZ4+QCGCiSBBeIf5frF2mbdNolheFlD6vlDOys1WCWDS5vYWIhNHZc8WXoLSUPnIOMDsrfYALaGuRBaNAqsiQRkA1N0gsIToBADlWZJOIB520+l4RNxAehroCsvM8/QCajb0Y4PlR/gr70dy/SAuMc3LnZxkXuNejsAayybVsLw5eGfJI+LK9o2/zNhc/cABqkxTVobDshClekzRQF1owJFByR3yZvP1xhC0TjmshCZbA+Ivhi5BTH/k60ztjjwUJe0yCW+IgRjn9AARYKD44qNlufMYOFw4X2gK+OZySg5x4G4v5JnYRx+IAse0/GDh+RpyETfgLsKkIDXWQ3t+4tNgL3Tw0Fni+DRijFdeGwZCKxM1SFCbY8Jyqw/GNCsM1j4/sYJslW3MOpvFn7WIgAWkHFmOh3Dh0gqvkMeYbLkKosb9oJtGwDD8S3w/TVZP4F5beGPuZVA0AnZpkzYRVlbG+/2PSPI6uy7aIGAWLQv+ASb2M7Gim2m8akiJ8/zAufBgOBSmbX5AgiD2EcxM3gwIBs29ulHMsh8BWII/cUg8B7OtAZs7FPrbL0lXYgfew/rI3x4lE86bAzBwptTiZe9s4i3T3ZilcShT8KpM4hh6s7sa/2UR2/J2lqEoIyxF9luTfCUZ4jrDd32itdPehjqxcjRw+1mHTx0QiyLBVt77G/WT5DZf+IwtAXSAmmBtEBaIC2QFkgL5IGALHv8OEtTwW3uzplOf1XQXspvMG9KN5aKSRL5njxeOSC9l3/CeN+xRHdv6PaJ3t6x07sCH8vdCT15k7F85PRZ7NPsxosgDAX51/d/igGeISDLF8WEE9HK64lFiBjr8bM/OC4+2SW7ZxWL78xscOOFk4VA/pLfU+L4929KgeyUEzBl8SlUykWYLIqcffbJAenCu1RTSN3crKlMvqfGAURiKN8iotSg3DGrk8EwcZHe+CwE0qWS1cniXwGQFwrkVTPlVfMs5+tLC0ShX84BKgHZyeSXGi7fGGe/6K3vXWN0y5MGyFnpcPcCuSnIqz0AECLhd9dlx4naFhX8e/fEIVx+wckiECqUU/ddcKw7gKjI994YJt9ZB9AlxA8yB08/5eueuwrXFoAQA3jLg1XvxPnbHUA05CUykA4L5Pz1JoPFHnJavr51s5Tw9k/kQlxpRwLmZ7d7eSUWuPxmID1OQhTI8qL0EczWGb73iTPOVLsSioDvyx308t4/Dd8NgXAKoUBeX9RRa4phn1DIvpQB6eIE+YJCClLJl8SCKrRUBsIrhABRRpp80hSvgelNacgrBLLrYW+S5P32HUB4hRAgStqnJQFyQfIlQD7KgEzPOO5KQHbfAERQCAZy1hZj2OJRHLtgQ9Gb1gWrDAKYYq+iyV1Z2d0JRFAIBqJI/qhoxU++AIPd5U5OC8JKOPH0ll2guSlTJXBFYhMgokKEWuvli1T5Ip2M83NW+n9iYZ61K+GA/dK7vWZtzZeqqNy9NAQiKkQAcuJbliWXp7u73q7LlZOoGcM0sQBINr/sel9drsw/4xbp/HHSACFTdOSVCimpfnc69wGSUIo1q9iVvvxyRkLpLrU5eopKCjhFR16pkBIgwEE/NPWmpqjOOO5qzGZKWyQdkCkRtJ68SiFlQN4UZSiKy0qAMCws5YIZcP9SUjVNiVme9SxNGXPvVQYCXeGkwlGUn6UyARpLWfn3Rab0tI0FANKVFFLWWH2oyrC3JRdmVY617Kr6+ZMcvriI/YoT80sJ+Q9JISWNFdkO6FHG3nFiW56U76AOakfNq8vHmp1i4+iEzQ/qcldCHhZUF+W+1rQrjwuTLF6noMafMmlteVG8MyVBqQdIvn2xRLJO4FOVK3JSUzylC6csP/Tkz2R+u2XaAmmBtECec/wPNLkv4aM45+gAAAAASUVORK5CYII=&amp;rdquo; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;
ちょっとここでは分かりにくいですが、コピペしてテキストエディタで表示してみると差は歴然でしょう。&lt;/p&gt;

&lt;p&gt;そんなわけで、データURIスキームの書式はこんな感じです。
&lt;pre&gt;&lt;code&gt;data:[メディアタイプ][;base64],データ&lt;/code&gt;&lt;/pre&gt;
まぁ変換ツールを使えば一発ですw
&lt;h4&gt;オンライン変換ツール&lt;/h4&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://websemantics.co.uk/online_tools/image_to_data_uri_convertor/&#34;&gt;Image To Data URI  Convertor - webSemantics&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://sveinbjorn.org/dataurlmaker&#34;&gt;DataURLMaker | Sveinbjorn  Thordarson&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://www.scalora.org/projects/uriencoder/&#34;&gt;data: URI image  encoder&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://software.hixie.ch/utilities/cgi/data/data&#34;&gt;The data:  URI  kitchen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
PHPが使える環境ならば、 file_get_contents関数ってのを使うと、画像修正の度にツールで変換することもなくなります。
&lt;pre&gt;&lt;code&gt;&lt;span style=&#34;color: #888888;&#34;&gt;&amp;lt;img src=&amp;ldquo;data:image/png;base64,&lt;/span&gt;&amp;lt;?php echo base64_encode(file_get_contents(&amp;ldquo;../images/feed-icon16x16.png&amp;rdquo;)) ?&amp;gt;&lt;span style=&#34;color: #888888;&#34;&gt;&amp;ldquo;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;容量の肥大化&lt;/h3&gt;
ただ、問題点もちらほらあります。Base64で表現しますと、元のバイナリデータより30~40%大きくなってしまうことです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://t32k.me/mol/wp-content/uploads/2010/04/base64.png&#34;&gt;&lt;img class=&#34;fig&#34; title=&#34;base64&#34; src=&#34;http://t32k.me/mol/wp-content/uploads/2010/04/base64.png&#34; alt=&#34;&#34; width=&#34;470&#34; height=&#34;270&#34; /&gt;&lt;/a&gt;
&lt;em&gt;&lt;span style=&#34;color: #808080;&#34;&gt;Image To Data URI Convertor - webSemantics より&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;上記のように、先程のフィードアイコンも元が764バイトに対して、Base64にエンコードした結果は1020バイトと約36%の増加となっています。というか、そもそもそのような長いコードをHTML内に記述すれば、フィードアイコンのある全てのページでHTML容量が増加してしまうことが考えられます。&lt;/p&gt;

&lt;p&gt;そのような時は、外部CSSファイル内に記述し、キャッシュを効かすのがよいかなと考えます。こんな具合に↓
&lt;pre&gt;&lt;code&gt;.hoge {
　width: 16px;　height: 16px;
　background-repeat: no-repeat;
　background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAKOSURBVHjadJNNSFRRGIbfc+6dO6OOOplDykSZaRCtnKRc+ANRUBFEm0gicxG0bGoVhERRYIvIjRAtW+UmW5QQQS6qRWQSWJRaUcjkT0LiVWfm/pzTd869M5LShe+eufC973m+n2Fj55KJymTt9ZgVy3AGMHoxvvEs/qZgDL4AlhbsAfv34g1TiRPxRMZbWwU3GQzO9clNhGcYBpkY4UlGiWRd5scnMvx5tUWano9IMoXy1pOUBPgz4xC/xv8r1hSexNKiB1Nhq6RIbQoVhy6i+MiCDffDEPyJITBvZZPYLwiQFFzVZ0Q45Moc8q8fwP34FGJ5FixaCevgBZT1DMNs7Nok9iikL8GyfWkZ3VgvhbljP6yOy2BbmzWR/+o2vM/PSmLfkchTaAIlsHa1ourSS5Sfvg8r3Q38mYb7+DzE9Ig2MDquAan2kth3AgKu0JSBapLCNranEWnPIHp2GDzZDEE3+1OBiXW4D4LHtViZCB/rBHJuHPmHp+CO3oK0Zyk7DvP4IGR1EwrPb673JX0mELslgvVRYW0O8usIvCe9AboyOdIPn1Ug9+Kupihr69ZiZSJFsYRwztbRO4icGARv6IT3ZkCTsKp68J2dyE2MQuZtsFgllbZHTyMsAVqsaldCVt8CtvsYPHsZzvtH+tZIc5e+sfBtLOhFYytRFAlYuGGED2clGNn8lO62m53U37y6XmM7M8E3onEIIpCSLp/vPyC31Bp6SUSsjmIbnO9jpVEZqbROzn15F5RDZs5CFs58FmaNBTZ5Ze+9hn11Genl/1mS0qjChumaCVvo2iViNXHkuD1g9Daxt7lVEQPMNpcSdah1pQb5kqho4yVXQc2iacHiMMpNFPia/jv/FWAAUTVTOunExzkAAAAASUVORK5CYII=);
}&lt;/code&gt;&lt;/pre&gt;
さらに欲をいえば、肥大化したCSSファイルをgzip圧縮すれば、Base64で増加した分など微々たるものと言えるでしょう。&lt;/p&gt;

&lt;p&gt;とはいえ、&lt;a href=&#34;http://www.ietf.org/rfc/rfc2397&#34;&gt;RFC2397&lt;/a&gt; (&lt;a href=&#34;http://www.darts.jp/reference/rfc/rfc2397-jp.txt&#34;&gt;邦訳&lt;/a&gt;)では、一応1024バイトまでと書いてあるし、Operaも4100バイトまでとのことなのでデータURIを適用する画像はアイコンなどの小さな画像に止めたほうが良いでしょう。
&lt;h4&gt;対応ブラウザ&lt;/h4&gt;
&lt;ul&gt;
    &lt;li&gt;Firefox2+ (100KBまで)&lt;/li&gt;
    &lt;li&gt;Safari&lt;/li&gt;
    &lt;li&gt;Chrome&lt;/li&gt;
    &lt;li&gt;Opera7.2+ (4100Bまで)&lt;/li&gt;
    &lt;li&gt;IE8 (32KBまで)&lt;/li&gt;
&lt;/ul&gt;
そういうわけで、長々とデータURIについて説明してきたわけだけど、これって&lt;strong&gt;IE5-7が対応してない&lt;/strong&gt;んですよね&amp;hellip;orz で、これらのブラウザにはどう対処しましょうかと考えたところ、JavaScriptで適用するというやり方もあるみたいだけど、なんだか難しいね&amp;hellip;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://www.yomotsu.net/lab/javascripts/ie6_data-cheme&#34;&gt;IE 7  以下で data スキームを URI 利用する | ヨモツネット&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/uupaa/20080904/1220462674&#34;&gt;IE5〜IE7でも、 RFC2397(Dataスキーム, DataURI)を使えるようにした! - latest log&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
単純にCSSハックでIE7以下には通常の画像を読み込ませるので良いかなと&lt;span style=&#34;text-decoration: line-through;&#34;&gt;あきらめたり&lt;/span&gt;考えたり&amp;hellip;
&lt;pre&gt;&lt;code&gt;.hoge {
　width: 16px;　height: 16px;
　background-repeat: no-repeat;
　background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAKOSURBVHjadJNNSFRRGIbfc+6dO6OOOplDykSZaRCtnKRc+ANRUBFEm0gicxG0bGoVhERRYIvIjRAtW+UmW5QQQS6qRWQSWJRaUcjkT0LiVWfm/pzTd869M5LShe+eufC973m+n2Fj55KJymTt9ZgVy3AGMHoxvvEs/qZgDL4AlhbsAfv34g1TiRPxRMZbWwU3GQzO9clNhGcYBpkY4UlGiWRd5scnMvx5tUWano9IMoXy1pOUBPgz4xC/xv8r1hSexNKiB1Nhq6RIbQoVhy6i+MiCDffDEPyJITBvZZPYLwiQFFzVZ0Q45Moc8q8fwP34FGJ5FixaCevgBZT1DMNs7Nok9iikL8GyfWkZ3VgvhbljP6yOy2BbmzWR/+o2vM/PSmLfkchTaAIlsHa1ourSS5Sfvg8r3Q38mYb7+DzE9Ig2MDquAan2kth3AgKu0JSBapLCNranEWnPIHp2GDzZDEE3+1OBiXW4D4LHtViZCB/rBHJuHPmHp+CO3oK0Zyk7DvP4IGR1EwrPb673JX0mELslgvVRYW0O8usIvCe9AboyOdIPn1Ug9+Kupihr69ZiZSJFsYRwztbRO4icGARv6IT3ZkCTsKp68J2dyE2MQuZtsFgllbZHTyMsAVqsaldCVt8CtvsYPHsZzvtH+tZIc5e+sfBtLOhFYytRFAlYuGGED2clGNn8lO62m53U37y6XmM7M8E3onEIIpCSLp/vPyC31Bp6SUSsjmIbnO9jpVEZqbROzn15F5RDZs5CFs58FmaNBTZ5Ze+9hn11Genl/1mS0qjChumaCVvo2iViNXHkuD1g9Daxt7lVEQPMNpcSdah1pQb5kqho4yVXQc2iacHiMMpNFPia/jv/FWAAUTVTOunExzkAAAAASUVORK5CYII=);
&lt;span style=&#34;color: #888888;&#34;&gt;  /* IE7 and below */  &lt;/span&gt;
　*background-image: url(&lt;a href=&#34;http://www.feedburner.com/fb/images/pub/feed-icon16x16.png&#34;&gt;http://www.feedburner.com/fb/images/pub/feed-icon16x16.png&lt;/a&gt;);
}&lt;/code&gt;&lt;/pre&gt;
まぁ、iPhone用サイトや、Firefoxのアドオンで使う画像など限定的な環境ならば全然使えると思うので試してはどうでしょうか。
&lt;h3&gt;参考サイト&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://www.websiteoptimization.com/speed/tweak/inline-images/&#34;&gt;Inline Images with Data URLs - embed graphics inline with data uri scheme&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://www.nczonline.net/blog/2009/10/27/data-uris-explained/&#34;&gt;Data URIs explained | NCZOnline&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Data:_URI_scheme&#34;&gt;data URI scheme - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>High Performance Web Design ~デザインから考えるハイパフォーマンスWebサイト~</title>
      <link>http://localhost:1313/mol/log/high-performance-web-design/</link>
      <pubDate>Tue, 24 Nov 2009 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/mol/log/high-performance-web-design/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.cssnite-ishikawa.jp/&#34;&gt;CSS Nite in ISHIKAWA&lt;/a&gt;で話をしてから1ヶ月経ったので、薄れゆく記憶の復習も兼ねて思いの丈を綴ってみたｗ
&lt;div id=&#34;__ss_2352987&#34; style=&#34;width: 425px; text-align: left;&#34;&gt;&lt;a style=&#34;margin: 12px 0pt 3px; font-family: Helvetica,Arial,Sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 14px; line-height: normal; font-size-adjust: none; font-stretch: normal; display: block; text-decoration: underline;&#34; title=&#34;High Performance Web Design&#34; href=&#34;http://www.slideshare.net/t32k/high-performance-web-design&#34;&gt;High Performance Web Design&lt;/a&gt;&lt;object style=&#34;margin: 0px;&#34; classid=&#34;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&#34; width=&#34;425&#34; height=&#34;355&#34; codebase=&#34;http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0&#34;&gt;&lt;param name=&#34;allowFullScreen&#34; value=&#34;true&#34; /&gt;&lt;param name=&#34;allowScriptAccess&#34; value=&#34;always&#34; /&gt;&lt;param name=&#34;src&#34; value=&#34;http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=wpo-091026191440-phpapp02&amp;amp;rel=0&amp;amp;stripped_title=high-performance-web-design&#34; /&gt;&lt;param name=&#34;allowfullscreen&#34; value=&#34;true&#34; /&gt;&lt;embed style=&#34;margin: 0px;&#34; type=&#34;application/x-shockwave-flash&#34; width=&#34;425&#34; height=&#34;355&#34; src=&#34;http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=wpo-091026191440-phpapp02&amp;amp;rel=0&amp;amp;stripped_title=high-performance-web-design&#34; allowscriptaccess=&#34;always&#34; allowfullscreen=&#34;true&#34;&gt;&lt;/embed&gt;&lt;/object&gt;&lt;/div&gt;
&lt;h3&gt;1. What&amp;rsquo;s High Performance?&lt;/h3&gt;
ここでいうパフォーマンスというのはWebサイトの表示高速化についてです。つまり、ページをいかに早く表示させるかという課題です。でも、そうゆうのってサーバー側の問題でしょ？システムエンジニアの管轄じゃないの？と思われがちですが「&lt;a href=&#34;http://warikiru.blogspot.com/2008/05/high-performance-web-sites.html&#34;&gt;ハイパフォーマンスWebサイト&lt;/a&gt;」の著者であるSteve Soudersの調査によると、&lt;span style=&#34;font-weight: bold;&#34;&gt;80:20&lt;/span&gt;。一般的にユーザーの待ち時間の実に80%がブラウザ側、フロントエンドで費やされていて、サーバー側、バックエンドでの時間は全体の20%でしかないという結果が出ています。つまり、サーバー側でデータベースのチューニングやメモリ管理、アルゴリズムの見直しなどして処理時間を半分にできたとしても全体として見れば10%でしかないということです。要するにフロントエンドを預かるWebデザイナーの責任が重大と言うことです。
&lt;h3&gt;2. Why High Performance?&lt;/h3&gt;
では、なぜパフォーマンスが重要なのでしょうか？パフォーマンスが悪いと何か都合が悪いのでしょうか？パフォーマンスをないがしろにしていると怖いよっていうデータを見せたいと思います。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://news.cnet.com/8301-10784_3-9954972-7.html&#34;&gt;&lt;span style=&#34;font-weight: bold;&#34;&gt;Google&lt;/span&gt;&lt;/a&gt;&lt;span style=&#34;font-weight: bold;&#34;&gt;：&lt;/span&gt;0.5秒遅くなると、検索数が20%減少する
うん、怖いですね、メインの事業ですからね。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-weight: bold;&#34;&gt;&lt;a href=&#34;http://www.scribd.com/doc/4970486/Make-Data-Useful-by-Greg-Linden-Amazoncom&#34;&gt;Amazon&lt;/a&gt;：&lt;/span&gt;0.1秒遅くなると、売り上げが1%減少する
怖いですね、たった0.1秒遅くなることで数十億、数百億ぐらいの影響になってくるということです。このようにパフォーマンスが低下すれば収益に直に影響してくるといったケースが考えられます。だけども、うちはAmazonみたいに大きくないから考えすぎだよとおっしゃりたいかもしれません。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.gomez.com/download/aberdeen-gomez-best-in-class.pdf&#34;&gt;&lt;span style=&#34;font-weight: bold;&#34;&gt;Aberdeen Group&lt;/span&gt;&lt;/a&gt;というリサーチ会社が出したレポートによると、一般的に表示スピードが1秒遅くなると、PVは11%、CVは7%、顧客満足度は16%ダウンするといったことが報告されています。こういった数値を知っていればパフォーマンス対策をするための目標を決めやすいのではないでしょうか。&lt;/p&gt;

&lt;p&gt;またユーザービリティ的に見てもパフォーマンス低下は避けた方良いということが分かります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.useit.com/papers/responsetime.html&#34;&gt;&lt;span style=&#34;font-weight: bold;&#34;&gt;反応時間の3つの重要限界&lt;/span&gt;&lt;/a&gt;
&lt;ul&gt;
    &lt;li&gt;心理的・感情的な違和感を感じないのは0.1秒まで&lt;/li&gt;
    &lt;li&gt;思考の流れが妨げられないのは1秒まで&lt;/li&gt;
    &lt;li&gt;注意力を維持できる限界の時間は10秒まで&lt;/li&gt;
&lt;/ul&gt;
結局のところ、Time is Money！と言えるのではないでしょうか。つまり、ページをハイパフォーマンス化することでユーザーのストレスをなくし、ユーザーエクスペリエンス（体験）の質を向上させることで、結果収益にもつながってくるこということです。
&lt;h3&gt;3. How do you measure it?&lt;/h3&gt;
次はどうやってページを計測・評価するのかといった面を考えてみましょう。&lt;/p&gt;

&lt;p&gt;計測するためにはパフォーマンスツールが必要です。いろいろあるのですが、大きくは2つに分けられると思います。Packet SniffersはWebページのコンポーネントつまり画像などの部品がどのようにダウンロードされているのか教えてくれます。Performance Analyzersはあらかじめ決められた項目を評価してくれるツールです。まぁ、見てみましょう。
&lt;h4&gt;Packet Sniffers&lt;/h4&gt;
&lt;a href=&#34;http://www.fiddler2.com/fiddler2/&#34;&gt;Fiddler&lt;/a&gt;, &lt;a href=&#34;https://addons.mozilla.org/ja/firefox/addon/1843&#34;&gt;Firebug Net Panel&lt;/a&gt;, &lt;a href=&#34;http://www.apple.com/jp/safari/&#34;&gt;Web Inspector Resources Panel&lt;/a&gt;
ひとつひとつがバーチャートがコンポーネントを表しています。チャートの長さがダウンロードにかかった時間ですね。このようにグラフィカルに表示してくれるので、どのバーチャートが一番長いのか着目すれば、ボトルネックがすぐ見つかります。これを取り去るか縮小させれば表示速度改善につながりますね。とはいっても、このように差がはっきりしていないときもありますので、パフォーマンス初心者にとってはちょっと敷居高いかもしれません。
&lt;h4&gt;Performance Analyzers&lt;/h4&gt;
Googleつくった&lt;a href=&#34;http://code.google.com/intl/ja/speed/page-speed/&#34;&gt;Page Speed&lt;/a&gt;というのものありますが、これ見た感じ文字ばっかて嫌になっちゃいますよね評価項目も細かいことばかりです。これはGoogleだからやっていることなので普通のサイトに当てはめるのはちょっと酷です。ということで、僕はこちらをお薦めします。Yahooがつくった&lt;a href=&#34;https://addons.mozilla.org/ja/firefox/addon/5369&#34;&gt;YSlow&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;13項目の視点からWebページをABCDEFの6段階でランク付けてくれます。これは良いですね。先程のPacket Sniffersは見たいに読み取る必要がないためです。総合評価がDと言われば次はCを目指そうと思うじゃないですか。各項目毎に評価してくれるのでちょっと見てみるとHTTPリクエストを減らしなさいよなどと注意されています。&lt;span style=&#34;font-weight: bold;&#34;&gt;Components&lt;/span&gt;はページの部品・パーツがどのくらいの数ダウンロードされているのか教えてくれます。&lt;span style=&#34;font-weight: bold;&#34;&gt;Statistics&lt;/span&gt;はコンポーネントの種類毎の容量が全体でのどのくらいの割合を占めているのか円グラフで表示してくれます。どうでしょうか、分かりやすい機能でやる気になってきませんか？僕は勝手にやる気になってきたので日本の主要なサイトをYSlowで評価してみました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lh4.ggpht.com/_1drnogi3vdg/SwvxbuZSrdI/AAAAAAAAAtA/Iwqu_HduDg8/yslow.png&#34; alt=&#34;YSlow評価結果&#34; /&gt;
&lt;span style=&#34;font-size: 85%;&#34;&gt;&lt;sup&gt;2009&lt;/sup&gt;&amp;frasl;&lt;sub&gt;10&lt;/sub&gt;/14  YSlow Ruleset applied: &lt;span style=&#34;font-weight: bold;&#34;&gt;Classic(V1)での評価&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;D, E, Cとか低い評価が目立ちますよね、これは仕方ないのかもしれません。というのも大抵のパフォーマンスを意識していないサイトはDかEといった評価になります（Ruleset:Classic(V1)で）。Cぐらいになって初めてここはちょっとパフォーマンスを意識しているなと感じるくらいです。Aにいたっては僕は2サイトしか知らないですね。GoogleとYSlowを作った米Yahoo!です。&lt;/p&gt;

&lt;p&gt;その&lt;a href=&#34;http://www.google.co.jp/&#34;&gt;Google&lt;/a&gt;なんですが、シンプルなページだからA評価当たり前だよねと思っちゃいそうですが、実は裏側を見てみますと。10個以上あったアイコンはCSSスプライトで1つの画像にまとまっていたり、シンプルなページであるのにも関わらず、さらに改行など取り除いてHTMLを圧縮しているなどの努力が見られます。こういった面もYSlowなら見逃さず評価してくれます。&lt;/p&gt;

&lt;p&gt;YSlowの使い方ですが、最初のインストールをしてしまえば、ほんの2,3ステップでチェックできるので、是非皆さんも、自分のサイト、競合他社、大手のサイトなどチェックしてみて自分がどういう位置にいるのか確認してみてください。&lt;/p&gt;

&lt;p&gt;というわけで、計測できないものは改善のしようがないということです。つまり、何か対策を行って評価しなければ次につながりません。対策→評価→対策→評価、このサイクルを回していくことで自ずとパフォーマンスは向上していくでしょう。
&lt;h3&gt;4. What should I do to improve?&lt;/h3&gt;
では、パフォーマンスを改善するために私たちは何をすべきなんでしょうか？
Yahoo!が出している高速サイトを実現するための14のルールは先程紹介したYSlowの評価項目に対応しているので、ハイパフォーマンスWebサイトの本と共に対策していけば良いでしょう。
&lt;ol&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;HTTPリクエストを減らす&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;CDNを使う&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;Expiresヘッダを設定する&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;コンポーネントをgzipする&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;スタイルシートは先頭に置く&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;スクリプトは最後に置く&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;CSS expressionの使用を控える&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;JavaScriptとCSSは外部ファイル化する&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;DNSルックアップを減らす&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;JavaScriptを縮小化する&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;リダイレクトを避ける&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;スクリプトを重複させない&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;ETagの設定を変更する&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;AJAXをキャッシュ可能にする&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;a href=&#34;http://journal.mycom.co.jp/news/2008/03/27/016/index.html&#34;&gt;&lt;img src=&#34;http://lh6.ggpht.com/_1drnogi3vdg/SwvxbrbUZxI/AAAAAAAAAtE/m3Eu7b2WxKA/yahoo.png&#34; alt=&#34;After A Grade 20 More Best Practices&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;さらにYSlowでA評価とった人のためにもっと細かい20のルールとしてこんなことも提示されています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://coliss.com/articles/build-websites/operations/web-performance-best-practices-from-google.html&#34;&gt;&lt;img src=&#34;http://lh3.ggpht.com/_1drnogi3vdg/SwvxcGf74gI/AAAAAAAAAtM/K65OfQKOCVE/google.png&#34; alt=&#34;Google Performance Best Practice&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;はたまた、Yahoo!に重複するところもありますが、GoogleのPerformance Best Practicesというのもあります。&lt;/p&gt;

&lt;p&gt;てか、多いですよねｗ　Too Many!&lt;/p&gt;

&lt;p&gt;これら全て対策しようと思ったらWebページのパフォーマンスがあがる前に、制作者のパフォーマンスがダウンしてしまいます。しかも、ほとんどの会社にはWebパフォーマンスを専門で担当する人なんていないと思います。僕もパフォーマンスばかりやってるわけではないですから。ここで重要なのは対策を闇雲にこなすのではなく、効果的なものから優先度をつけて順にやれるところから行っていくことです。つまり、使えるリソースは有限だということです。
&lt;div style=&#34;text-align: center;&#34;&gt;&lt;span style=&#34;font-weight: bold;&#34;&gt;Make Fewer HTTP Requests&lt;/span&gt;
&lt;span&gt;HTTPリクエストを減らす&lt;/span&gt;&lt;/div&gt;
ということで、今回最も有効な対策、一番始めに考えるべき対策としてこれを挙げます。今日はこれだけです。本当にこれだけです。先程の14の対策を紹介したのですが、14全てやれば100%パフォーマンスが改善されるのかというと、そうでもありません。先のルールは有効的な対策として考えられるものから列挙してあるので、一番最初に紹介されているHTTPリクエストを減らすに対応するだけサイトが50%も速く表示されるようになったと言うケースも報告されています。
&lt;h4&gt;What’s HTTP Requests?&lt;/h4&gt;
HTTPリクエストとはなんぞ？ってことですが、画像、スクリプト、スタイルシート、FlashなどのサーバーにHTTPプロトコルでサーバーにリクエストしているものですね。
&lt;h4&gt;Make Fewer HTTP Requests&lt;/h4&gt;
HTTPリクエストを減らす方法としてハイパフォーマンスWebサイトの本では以下のようなことを挙げています。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-weight: bold;&#34;&gt;Image Maps&lt;/span&gt;
うん、Webをまったく知らなかった大学生の頃に多用した。ボタンなどの画像を1個1個切り出すよりもまとめて1枚画像としたほうがリクエスト減らせますよと言うことです。
&lt;span style=&#34;font-weight: bold;&#34;&gt;CSS Sprites&lt;/span&gt;
先程のGoogleのように、CSSを用いて一枚の画像を複数の画像のように見せることでリクエスト数を減らしています。
&lt;span style=&#34;font-weight: bold;&#34;&gt;Inline Images&lt;/span&gt;
URLに画像データを長っい文字列として表現してそこから画像を生成するのでリクエストをしない。が多用するとコード量が増えるのが難点。
&lt;span style=&#34;font-weight: bold;&#34;&gt;Combined Scripts and Stylesheets&lt;/span&gt;
JSとかCSSファイルをモジュール毎に管理するのは良いのだけれど、パフォーマンス的にはそれら１個にまとめた方が良いよとのこと。（開発時はモジュールで管理してページ生成時に動的にファイルを結合するやり方もあるのでシステムさんに相談してみよう。&lt;a href=&#34;http://code.google.com/p/modconcat/&#34;&gt;modconcat&lt;/a&gt;とか）&lt;/p&gt;

&lt;p&gt;というか、めんどくさいっすよねｗｗ
なんでこんなめんどくさいことをやらなければいけないのか。
そうは思いませんか。僕は思います。&lt;/p&gt;

&lt;p&gt;似たような話で&lt;a href=&#34;http://d.hatena.ne.jp/keyword/%A5%ED%A5%B7%A5%A2%A4%CF%B1%F4%C9%AE%A4%F2%BB%C8%A4%C3%A4%BF&#34;&gt;Space Pen&lt;/a&gt;という話がありますのでちょっと紹介。
ここで重要なのはボールペンという枠組みに固執することなく鉛筆という解を導き出したということです。今回のケースにおいてこの鉛筆にあたるのは何でしょうか？僕はデザインだと考えます。&lt;/p&gt;

&lt;p&gt;つまり、デザイン・設計の段階からパフォーマンス意識すれば難しいことはしなくてもいいんです。最初からHTTPリクエストを増やすようなデザインにしなければいいんです。&lt;/p&gt;

&lt;p&gt;じゃなぜ、HTTPリクエスト一杯のデザインになってしまうのでしょうか？そう考えたときに、僕の短いWebデザイナー人生とネットサーフィンをしてて思うサイト制作者が陥りやすい3つの欲求としてこんなことが挙げられるんではないかと思います。自分も含めて。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-weight: bold;&#34;&gt;目立たせたい！&lt;/span&gt;
あれやこれやと目立たせることで画像だらけになってリクエストが増えてしまう。
&lt;span style=&#34;font-weight: bold;&#34;&gt;多機能にしたい！&lt;/span&gt;
あれやこれやと機能を付加することでJSファイルの読み込みすぎといったことが考えられます。
&lt;span style=&#34;font-weight: bold;&#34;&gt;とりあえず、全部載せたい&lt;/span&gt;
あれやこれやと自サイトのセールスポイントを挙げてしまい長大なページになってリクエストも増える。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lh5.ggpht.com/_1drnogi3vdg/Swvxi01iTEI/AAAAAAAAAtY/VmTsVCBGhhE/5plan.png&#34; alt=&#34;5 Planes Model&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これらを考える上で、&lt;a href=&#34;http://www.jjg.net/elements/&#34;&gt;Jesse James Garrettの5 Planes Model&lt;/a&gt;をフレームワークとして使うと、第1の目立たせたい！は&lt;span style=&#34;font-weight: bold;&#34;&gt;表層&lt;/span&gt;、&lt;span style=&#34;font-weight: bold;&#34;&gt;骨格&lt;/span&gt;に当たる問題だと考えます。
&lt;h4&gt;1. 目立たせたい！&lt;/h4&gt;
そもそも目立つとは何なのでしょうか。目立つ目立たないは周りとのオブジェクトの対比であって、必ずしも画像にすれば良いというわけでありません。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lh6.ggpht.com/_1drnogi3vdg/Swvxi4yj4nI/AAAAAAAAAtU/8oI6UcmOH9M/case.png&#34; alt=&#34;Case&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このCaseのようにさまざまなステークホルダーが主張を通した結果、1ページに沢山の画像が溢れています。このようなページが本当に制作側の思い通り、見られるのか検証してみる必要あります。&lt;a href=&#34;http://www.feng-gui.com/&#34;&gt;Feng-GUI&lt;/a&gt;という人間の視覚の動きをシミュレートしてくれるサービスがあるので、先程のページデザインをシミュレートしてみると、全ての画像が目立っていないことが分かります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lh5.ggpht.com/_1drnogi3vdg/SwvxcJCVPFI/AAAAAAAAAtQ/MBlGyCGOYdg/cssnite.png&#34; alt=&#34;CSS Nite Banner Test&#34; /&gt;&lt;/p&gt;

&lt;p&gt;また、本当に画像にすれば目立つのかという疑問が僕の中で大きかったので実験してみました。自分のブログにて、右上部に「CSS Nite 石川に出ることになりました」というバナーを置いて、テキストリンク・画像ボタンで「詳細はこちら」表現したものを比較してみました。結果、テキストリンクで表示したほうが画像ボタンに比べて、90%以上多くクリックされました。&lt;span style=&#34;font-size: 85%;&#34;&gt;（参考：&lt;a href=&#34;http://cssnite.jp/archives/post_1575.html&#34;&gt;CSS Nite in Ginza, Vol.37：フォローアップ&lt;/a&gt;）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;また、クックパッドのプレミアム会員への入会導線比較においても、バナー画像よりも、テキストリンクの方が3倍の効果を挙げたというデータが出ています。文脈（このケースの場合、プレミアムサービスに検索結果の並べ替えが含まれていたので、検索結果ページでの誘導が効果を発揮したということが分かる）を理解すれば必ずしも画像にする必要はないということが分かります。&lt;span style=&#34;font-size: 85%;&#34;&gt;（出典：&lt;a href=&#34;http://cssnite.jp/archives/post_1460.html&#34;&gt;CSS Nite in Ginza, Vol.32：フォローアップ&lt;/a&gt;）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;つまり、デザインというのはデコレーションではありません。大事なのはコンテンツです。厚化粧することコンテンツを見えにくくしてはいけません。デザインというのはコンテンツをうまく伝えるための最適な手段を考えることです。
&lt;h4&gt;2. 多機能にしたい！&lt;/h4&gt;
骨格、構造、要件、多岐にわたる要素を含んでいます。この背景にはjQueryやPrototypeなどのAJAXライブラリが普及してきたことによって、Webデザイナーでも比較的簡単にインタラクティブなサイトを制作できるようになってきたことが考えられます。&lt;/p&gt;

&lt;p&gt;また、個人レベルにおいてもブログパーツの浸透などで、安易にブログパーツは貼り付けていけば、それに伴いJSファイルなどの増加の危険性が考えられます。自分のブログが何位だとかそういった自己顕示欲を主張するパーツなどはどんどん取り去っていけば良いのですが、リッチインタラクションと呼ばれる部分は難しいものがあります。&lt;/p&gt;

&lt;p&gt;カルーセル、アコーディオン、ドラッグ&amp;amp;ドロップなどのリッチインタラクションはある人にとっては便利と感じるかもしれません、しかしある人にとってはよく分からないと映るかもしれません。何を採用して何を採用しないか判断するためにはウェブ解析をする必要あります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.google.com/analytics/home/?hl=ja&#34;&gt;Google Analytics&lt;/a&gt;であなたのサイトのユーザーが使っているブラウザが何なのか分かります。もし、IE6などの古いブラウザのユーザーが大半ならば、リッチインタラクションを実現するためのJSファイルでブラウザがもたつくかもしれません。そうゆう場合はやめておいたほうが無難でしょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.google.com/analytics/siteopt/?et=reset&#34;&gt;Google Website Optimizer&lt;/a&gt;では先程のバナーテストのように多変量テスト、A/Bテストが可能です。テストした結果、リッチインタラクションがあったほうが、コンバージョン率がいいというのなら採用しても良いかもしれません。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://userheat.com/&#34;&gt;User Heat&lt;/a&gt;はFeng-GUIのように大まかなヒートマップを作成してくれます。もし、該当の機能部分がまったく見向きもされていなければ、素直に外しておきましょう。&lt;/p&gt;

&lt;p&gt;何かを追加すれば、誰からしらの役に立つから良いのではないかと考えがちですが、&lt;a href=&#34;http://www.ideaxidea.com/archives/2008/03/37_signals.html&#34;&gt;37Signalsも自問している&lt;/a&gt;ことに、”価値とは加えることと取り去ることのバランスなのです”とあるように、時としては引き算をすることで価値を増やせることも可能なのです。&lt;/p&gt;

&lt;p&gt;結局はユーザーが何を欲しているのか、聞かなければなりません。Webデザイナーであろうとも、ウェブ解析ツールなど使うことで（今回紹介したツールはすべて無料）ユーザーのフィードバックを得ることできます。そして、無用な機能を実現するためのリクエストを削減することができます。
&lt;h4&gt;3. とりあえず、全部載せたい！&lt;/h4&gt;
これは要件、戦略にあたる内容でしょうか。長すぎるページというのが存在します。果たして、このようなページは本当に読まれているのでしょうか？&lt;a href=&#34;http://warikiru.blogspot.com/2008/09/visitor-attention-and-web-page-exposure.html&#34;&gt;Click Tale社の調査&lt;/a&gt;によると、ページの露出は上部から540pxを境に急激に下降しており、ユーザーが流し読みしていることが考えられます。&lt;a href=&#34;http://www.usability.gr.jp/alertbox/whyscanning.html&#34;&gt;なぜユーザーは流し読みする&lt;/a&gt;のでしょうか。Jakob Nielsenは以下のことを挙げています。
&lt;ul&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;コンピュータ画面で読むのは目が疲れる。&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;ウェブはユーザ主導型のメディアである。&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;他の何億ものページと競争しなくてはならない。&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 85%;&#34;&gt;現代生活はあわただしい。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
読まれないのなら読まれないで結構なのですが、Webサイトが存在する以上、なんらかのビジネスゴール：サイトの目的、ページレベルで言えば、してほしいアクションがあると思います。企業サイトであれば、資料請求のボタンを押すとかEコマースサイトならば商品をカートに入れるなどのアクションが考えられます。そういったアクションが長大なページの中に存在すれば、コンバージョンを下げる可能性も出てきます。
&lt;div style=&#34;text-align: center;&#34;&gt;決断に要する時間は、選択肢が増えるほど長くなる。
ヒック・ハイマンの法則&lt;/div&gt;
つまり、目的を分割する必要があります。この辺はiPodの戦略がうまいかと思います。iPod, iTunes, iTunes Storeで目的を分けることで最適なエクスペリエンスを提供しています。考えてもみれば、iPodの小さな画面で曲名なんて編集したくないですよね。&lt;/p&gt;

&lt;p&gt;Webサイトも同じで&lt;span style=&#34;font-weight: bold;&#34;&gt;1ページ 1テーマ 1スクリーン&lt;/span&gt;を心がけることで、サイト制作者はユーザーに伝えたいことをより正確に伝えられるわけで、ユーザーもより理解が早くなる。そしてHTTPリクエストが必要以上に増えることもない。そのためには自分がサイトで何を伝えたいのか、ユーザーにどうしてほしいのか考えることで無駄をそぎ落とすことが可能です。&lt;/p&gt;

&lt;p&gt;結局は人は求める結果が利益となると思うのなら待つのです。おいしいと評判のお店があると聞いたら並んで待つでしょ？僕もFlashの神様と言われる&lt;a href=&#34;http://twitter.com/yugop&#34;&gt;中村勇吾さん&lt;/a&gt;が制作したFlashサイトなら3分でも待ちますよ。&lt;/p&gt;

&lt;p&gt;しかし、一般的に、ユーザーが検索でたまたま見つけたサイトでは、あなたのサイトが本当は素晴らしいモノを提供していてもユーザーはその時点では知らないのです。ですので、そこで機会損失してしまうよりかはパフォーマンスをできる限り向上させておくのが吉となるのではないでしょうか。
&lt;h3&gt;5. Conclusion&lt;/h3&gt;
パフォーマンスは収益やUXに大きく影響します。YSlowという計測ツールを手に入れました。パフォーマンスを上げるためにHTTPリクエストを減らすことが最優先事項です。そのためにはサイトで何をしたいのか、明確な目標を定めることが必要です。そうすれば、一貫性のあるデザインをすることができ、簡潔なコードにつながり、ハイパフォーマンスWebサイト！みんなHAPPY！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lh6.ggpht.com/_1drnogi3vdg/Swvxb30Xt_I/AAAAAAAAAtI/QRGYdfujud8/thank.jpg&#34; alt=&#34;Thank You!&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ありがとうございました。
Thank you!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design Fast Websites (Don’t Blame the Rounded Corners)</title>
      <link>http://localhost:1313/mol/log/design-fast-websites/</link>
      <pubDate>Wed, 24 Dec 2008 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/mol/log/design-fast-websites/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.atmarkit.co.jp/news/analysis/200812/22/chrome.html&#34;&gt;Chromeはなぜ速いのか － ＠IT&lt;/a&gt;の記事が話題になってて、少し内容がリンクしていたので、紹介。&lt;a href=&#34;http://journal.mycom.co.jp/articles/2008/01/29/yslow/&#34;&gt;YSlow&lt;/a&gt;でおなじみのYahoo! Performance Teamのスライドです。&lt;/p&gt;

&lt;p&gt;&lt;iframe style=&#34;border: 1px solid #CCC; border-width: 1px 1px 0; margin-bottom: 5px;&#34; src=&#34;http://www.slideshare.net/slideshow/embed_code/658403&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; width=&#34;427&#34; height=&#34;356&#34;&gt;&lt;/iframe&gt;
&lt;div style=&#34;margin-bottom: 5px;&#34;&gt;&lt;strong&gt; &lt;a title=&#34;Design Fast Websites&#34; href=&#34;http://www.slideshare.net/stubbornella/designing-fast-websites-presentation&#34; target=&#34;_blank&#34;&gt;Design Fast Websites&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;http://www.slideshare.net/stubbornella&#34; target=&#34;_blank&#34;&gt;Nicole Sullivan&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;a href=&#34;http://yuiblog.com/blog/2008/12/23/video-sullivan/&#34;&gt;YUI Theater — Nicole Sullivan: &amp;ldquo;Design Fast Websites (Don’t Blame the Rounded Corners)&amp;rdquo;&lt;/a&gt;より&lt;/p&gt;

&lt;p&gt;パフォーマンスに関するデザインの話っぽいので、食いつきましたw
まず、なぜパフォーマンスを意識しなければならないのか？
ということに関して3つの理由を挙げています。
&lt;ul&gt;
    &lt;li&gt;Because fast is better&lt;/li&gt;
    &lt;li&gt;Because sites are bigger&lt;/li&gt;
    &lt;li&gt;Time is money&lt;/li&gt;
&lt;/ul&gt;
1つ目は、速いは正義ですね。ウェブを速く表示することで誰も困らないですしね。
2つ目は、年々ウェブサイトは大容量化してるそうです。Ajaxを使ったウェブアプリケーション、ディスプレイの大型化に伴うサイトのワイド化など考えられます。
3つ目、時は金なりということで、以下のようになってます。
&lt;ul&gt;
    &lt;li&gt;+100ms Amazon : 1% drop in sales&lt;/li&gt;
    &lt;li&gt;+400ms Yahoo! : 5-9% drop in full-page traffic&lt;/li&gt;
    &lt;li&gt;+500ms Google : 20% fewer searches&lt;/li&gt;
&lt;/ul&gt;
アマゾンで0.1秒遅くなれば、1%売り上げが落ち、
ヤフーで0.4秒遅くなれば、全ページで5~9％のトラフィックが減少し、
グーグルで0.5秒遅くなれば、検索数が20%落ちるそうです。&lt;/p&gt;

&lt;p&gt;ウェブ開発の理念としては、
&lt;ul&gt;
    &lt;li&gt;デザインに敬意を払って作業をしなさい。
Work out of respect for the design.&lt;/li&gt;
    &lt;li&gt;デザイナーは私たちのコードを内側から見たとき同じくらいに美しく巧みなビジュアルにしてくれる。
Designers make our code as beautiful and clever on the outside as it is on the inside.&lt;/li&gt;
    &lt;li&gt;元のデザインのビジョンを尊重しなさい。
（一貫したデザインはクリーンなコードを生み、それがサイトを早くする）
Respect the original design vision. consistent design = clean code = fast site.&lt;/li&gt;
&lt;/ul&gt;
などのようなことを挙げられています。
嬉しい反面デザイナーとして責任重大です＞＜&lt;/p&gt;

&lt;p&gt;9つの実践としては、
あんまりというかほとんど聞き取れなかったので、話半分に。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. スマートなオブジェクトのコンポーネントライブラリを作りなさい。&lt;/strong&gt;
Create a component library of smart objects
これは、そのままですね。レゴを作るかのようにモジュールを決めて、
冗長性を避けることですね。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. セマンティックなスタイルを一貫して使用しなさい&lt;/strong&gt;
Use consistent semantic style
意味に即したスタイルを指定しなさいということかな。
見出しなのに、10pxなんてありえないだろみたいな。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 透明になるように（内部で）モジュールをデザインしなさい。&lt;/strong&gt;
Design modules to be transparent on the inside
透過画像を使ってうまくデザイン要素を組み合わせることですかね。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 画像の最適化と(CSS)スプライト&lt;/strong&gt;
Optimize images and sprites
この辺は&lt;a href=&#34;http://smushit.com/&#34;&gt;smush it!&lt;/a&gt;なんか使って画像を最適化しろみたいな内容です。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 非標準のブラウザのフォントを避けなさい&lt;/strong&gt;
Avoid non-standard browser fonts
これはブラウザに搭載していないフォントを使いたいがために画像で書き出すことをやめろというのか、それともほんとに、font-familiyでマニアックな書体を指定するなってことかな。よく聞き取れませんでした。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. 行よりも列（コラム）を使用しなさい&lt;/strong&gt;
Use columns rather than rows
これも、CSSでは縦のラインは合わせられるけど、水平ライン（ボックスの高さ）を合わせようとしたら、JavaScriptとか使わなきゃいけないから、コラムレイアウトの方がいいよーみたいなことだと思う。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7. キラキラなデザインは慎重に採用しなさい&lt;/strong&gt;
Choose your bing carefully
いわゆる Web 2.0 的なグラデーションを多用すれば画像サイズも膨らむし、本当にターゲットとしたユーザーが必要としているのか考えるべき。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8. フレキシブルに＜&lt;/strong&gt;
Be flexible.
フレキシブルに＞&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9. グリッドを愛することを学びなさい。&lt;/strong&gt;
Learn to love grids
グリッドレイアウトの方が、コンテンツの追加・削除が容易なんだと思う。
それで、コードをクリーンに保てるんだと思う。
とまぁ、こんな感じの内容のプレゼンです。
興味のある人、英語のできる人は詳しい内容教えてくだされ～&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>